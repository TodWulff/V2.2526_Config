#####################################################################
#  gcode processing
#####################################################################

[gcode_macro _gcodeproc_vars]
description:  module variables

variable_gcodeproc_verb_error:		1		# set to 0 to mute error reporting (um, errors.  lol)
variable_gcodeproc_verb_info:		0	   # set to 0 to mute info reporting (has data)
variable_gcodeproc_verb_status:		0	   # set to 0 to mute status reporting (useful modes, update, etc.)
variable_gcodeproc_verb_debug:		0	   # set to 0 to mute debugs stuffs I added (proc entry/exit)
variable_gcodeproc_verb_codeflow:	0		# set to 0 to mute code flow stuffs I added (proc entry/exit)

#	SET_GCODE_VARIABLE MACRO=_gcodeproc_vars VARIABLE=dynamic_extrate_enable VALUE=1
variable_dynamic_extrate_enable:		1

#	SET_GCODE_VARIABLE MACRO=_gcodeproc_vars VARIABLE=dynamic_spdrate_enable VALUE=1
variable_dynamic_spdrate_enable:		1

gcode:
	# there is none

#--------------------------------------------------------------------

[delayed_gcode _gcodeproc_module_start]		 
#description: Sets module-specific state flags for conditional use elsewhere.
initial_duration: 0.5							# have this at 0.5s as init code in _startup_autoexec.cfg runs at 0.1s after start
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_gcodeproc_module_start func_params='"{rawparams|string}"'  {% endif %}

 	{% if printer["gcode_macro _printer_vars"].ptr_verb_modload %}  M118 >>> _gcodeproc_module_start Start <<< {% endif %}

	SAVE_VARIABLE VARIABLE=module_gcodeproc_loaded VALUE=1					#flag via persistent variable that this module is loaded
	SAVE_VARIABLE VARIABLE=gcodeproc_err_flag VALUE=0						#init error flag via persistent variable that this module is not in error

	{% if printer["gcode_macro _printer_vars"].ptr_verb_modload %}  M118 >>> _gcodeproc_module_start End <<< {% endif %}
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end {% endif %}

#--------------------------------------------------------------------

[gcode_macro _SetSlicerVar]
description: Used to runtime set slicer variables contained in gcode (done at slice time w/ regex post processing) 
# added ability to call dynamic PA setting based on mesh line type (Cura has a plugin, PS doesn't...)
# added logic to prevent inadvertent mid-print lowering of maxz due to OAAT/Sequential printing.
# WIP stuffs that I nix'd for now...
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_SetSlicerVar func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}				# set eazy accesss context for save_variables object

	{% if printer["gcode_macro _gcodeproc_vars"].gcodeproc_verb_codeflow %}  M118 >>> _SetSlicerVar Start <<< {% endif %}

	# for mesh type specific functionality
	{% if params.VARIABLE|string == "TYPE" %}
	
		{% set mesh_name = params.VALUE|string %}
		
		# if enabled, sets a dynamic PA setting based on mesh/line type (see _linear_advance | _linadv_vars)
		{% if svv.module_linadv_loaded %}
			{% if printer["gcode_macro _linadv_vars"].dynamic_pa_enable %}
				_SetDynamicPA MESH={mesh_name}
			{% else %}
				# do nothing here
			{% endif %}
		{% endif %}
	
		# if enabled, sets a dynamic extrusion rate multiplier setting based on mesh/line type (see _gcode_processing.cfg | _gcodeproc_vars)
		{% if printer["gcode_macro _gcodeproc_vars"].dynamic_extrate_enable %}
			_SetDynamicExtRate MESH={mesh_name}
		{% else %}
			# do nothing here
		{% endif %}
	
		# if enabled, sets a dynamic speed rate multiplier setting based on mesh/line type (see _gcode_processing | _gcodeproc_vars)
		{% if printer["gcode_macro _gcodeproc_vars"].dynamic_spdrate_enable %}
			_SetDynamicSpdRate MESH={mesh_name}
		{% else %}
			# do nothing here
		{% endif %}

	{% endif %}
	
	{% if params.VARIABLE|string == "maxz" %}
		# fix maxz to not overwrite a equal or higher saved value as a
		# 'one at a time'/'sequential' context will have implications
		# https://help.prusa3d.com/en/article/sequential-printing_124589
		# print start/end/canx overtly resets maxz to 0.0 between prints
		{% set svv_VALUE = params.VALUE|replace("\"","")|float %}	# convert float string to a proper float
		{% if printer["gcode_macro _printer_vars"].ptr_verb_info %}
			M118 >>> maxz raw:{params.VALUE} val:{svv_VALUE} <<<
		{% endif %}
		{% if svv.maxz|float < svv_VALUE|float %}
			{% if printer["gcode_macro _printer_vars"].ptr_verb_info %}
				M118 >>> SAVING MAXZ:{svv.maxz|float} THIS:{svv_VALUE|float} <<<
			{% endif %}
			SAVE_VARIABLE VARIABLE={params.VARIABLE|string} VALUE={svv_VALUE|float}
		{% else %}
			{% if printer["gcode_macro _printer_vars"].ptr_verb_info %}
				M118 >>> SKIPPED MAXZ UPDATE - SAVED:{svv.maxz|float} THIS:{params.VALUE|float} <<<
			{% endif %}
		
		{% endif %}
	{% else %}
		## forcibly save numbers as numbers (int/float) and not within strings, even though passed numbers are stringified
		{% if params.VALUE|replace("\"","")|int|string == params.VALUE|replace("\"","")|string %}		# test for int
			{% set svv_VALUE = params.VALUE|replace("\"","")|int %}
			SAVE_VARIABLE VARIABLE={params.VARIABLE|string} VALUE={svv_VALUE}
		{% elif params.VALUE|replace("\"","")|float|string == params.VALUE|replace("\"","")|string %}	# test for float
			{% set svv_VALUE = params.VALUE|replace("\"","")|float %}
			SAVE_VARIABLE VARIABLE={params.VARIABLE|string} VALUE={svv_VALUE}
		{% else %}									
			{% set svv_VALUE = "'\"" + params.VALUE|string + "\"'" %}									# it's not a number
			SAVE_VARIABLE {rawparams}
		{% endif %}
	{% endif %}

	{% if printer["gcode_macro _gcodeproc_vars"].gcodeproc_verb_codeflow %}  M118 >>> _SetSlicerVar End <<< {% endif %}

#--------------------------------------------------------------------

[gcode_macro M1170]
description:  workaround for fixing a zero-based layer display - slicer is zero-based, gray matter is 1-based...
# params = L=LAYERNUM T=TOTALLAYERS  Weirdly, while PS layer is 0-based, PS's total layer count is 1-based...
# sample slicer use: M1170 L[layer_num] T[total_layer_count]
# chose this approach vs. renaming stock M117, as M117 works otherwise - this addresses a specific slicer behaviour.
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=M1170 func_params='"{rawparams|string}"'  {% endif %}

	M117 Layer {(params.L|int + 1)|int}/{params.T|int}

#--------------------------------------------------------------------

[gcode_macro _SetDynamicExtRate]
description: Used to set klipper's Extrusion Rate Multiplier based on specific mesh types passed in gcode
# parameter to be passed is a case-insenitive spaces-inclusive string MESH="mesh name"
# this is a stop-gap effort, in the event the slicer doesn't provide the functionality needed
# inspired by dynamic linear advance AND dynamic speed rate
# see _SetDynamicSpdRate comments
variable_mesh_name =	["Unknown",	"Perimeter",	"External perimeter",	"Overhang perimeter",	"Internal infill",	"Solid infill",	"Top solid infill",	"Ironing",	"Bridge infill",	"Gap fill",		"Skirt/Brim",	"Support material",	"Support material interface",	"Wipe tower",	"Custom",	"Mixed"		]
#range on the following tuple members is 0.0 to 2.0 [suggested limit]
variable_mesh_extrate =	[1.0,			1.0,			1.0,						1.0,					1.0,			1.0,			1.0,				1.0,		1.0,				1.0,			1.0,			1.0,				1.0,							1.0,			1.0,		1.0	]

gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_SetDynamicExtRate func_params='"{rawparams|string}"'  {% endif %}

	{% if printer["gcode_macro _gcodeproc_vars"].dynamic_extrate_enable %}

	{% if printer["gcode_macro _gcodeproc_vars"].gcodeproc_verb_codeflow %}  M118 >>> _SetDynamicExtRate Start <<< {% endif %}

		{% set this1 = namespace(pa_unset=true) %}
		{% set this2 = namespace(matches=0) %}
		
		{% for mesh_idx in range(printer["gcode_macro _SetDynamicExtRate"].mesh_name|length) %}
			{% if params.MESH|string|lower == printer["gcode_macro _SetDynamicExtRate"].mesh_name[mesh_idx|int]|string|lower %}
				M221 S{(printer["gcode_macro _SetDynamicExtRate"].mesh_extrate[mesh_idx|int]|float * 100)|int}
				{% set this1.pa_unset = false %}
				{% set this2.matches = this2.matches + 1 %}
			{% endif %}
		{% endfor %}

		{% if this1.pa_unset %}
			{% if printer["gcode_macro _gcodeproc_vars"].gcodeproc_verb_error %} 
				M118 >>> _SetDynamicExtRate|UNKNOWN MESH: {params.MESH|string|lower} <<< 
			{% endif %}		
			M300 S200 P50	# emit shortest possible low-freq bloop, a low-irritation get-user-attention thing about no mesh-specific setting
		{% endif %}
		
		{% if this2.matches > 1 %}
			{% if printer["gcode_macro _gcodeproc_vars"].gcodeproc_verb_error %} 
				M118 >>> _SetDynamicExtRate|Multiple matches on MESH: {params.MESH|string|lower} - matched {this2.matches} times <<< 
			{% endif %}		
			M300 S200 P50	# emit shortest possible low-freq bloop, a low-irritation get-user-attention thing about multiple matches
		{% endif %}
		
	{% if printer["gcode_macro _gcodeproc_vars"].gcodeproc_verb_codeflow %}  M118 >>> _SetDynamicExtRate End <<< {% endif %}
		
	{% endif %}

#--------------------------------------------------------------------

[gcode_macro _SetDynamicSpdRate]
description: Used to set klipper's Speed Rate Multiplier based on specific mesh types passed in gcode
# parameter to be passed is a case-insenitive spaces-inclusive string MESH="mesh name"
# this is a stop-gap effort, in the event the slicer doesn't provide the functionality needed
# inspired by dynamic linear advance AND dynamic extrusion rate
#
# this is namely for being able to slow down inner exterior perimeters, esp those that overhang, to keep filament from pulling away
# PS's overhang perimeter type is, in my opine, too selective and is not useful in mitigating inner external-perimeters from
# pulling away from the model at fast print speeds - I may be looking at this wrong, but the logic rings true in muh gray matter...
variable_mesh_name =	["Unknown",	"Perimeter",	"External perimeter",	"Overhang perimeter",	"Internal infill",	"Solid infill",	"Top solid infill",	"Ironing",	"Bridge infill",	"Gap fill",		"Skirt/Brim",	"Support material",	"Support material interface",	"Wipe tower",	"Custom",	"Mixed"		]
#range on the following tuple members is 0.0 to 2.0 [200% suggested limit]
variable_mesh_spdrate =	[1.0,			1.0,			1.0,						1.0,					1.0,			1.0,			1.0,				1.0,		1.0,				1.0,			1.0,			1.0,				1.0,							1.0,			1.0,		1.0	]

gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_SetDynamicSpdRate func_params='"{rawparams|string}"'  {% endif %}

	{% if printer["gcode_macro _gcodeproc_vars"].dynamic_spdrate_enable %}

	{% if printer["gcode_macro _gcodeproc_vars"].gcodeproc_verb_codeflow %}  M118 >>> _SetDynamicSpdRate Start <<< {% endif %}

		{% set this1 = namespace(pa_unset=true) %}
		{% set this2 = namespace(matches=0) %}
		
		{% for mesh_idx in range(printer["gcode_macro _SetDynamicSpdRate"].mesh_name|length) %}
			{% if params.MESH|string|lower == printer["gcode_macro _SetDynamicSpdRate"].mesh_name[mesh_idx|int]|string|lower %}
				M220 S{(printer["gcode_macro _SetDynamicSpdRate"].mesh_spdrate[mesh_idx|int]|float * 100)|int}
				{% set this1.pa_unset = false %}
				{% set this2.matches = this2.matches + 1 %}
			{% endif %}
		{% endfor %}

		{% if this1.pa_unset %}
			{% if printer["gcode_macro _gcodeproc_vars"].gcodeproc_verb_error %} 
				M118 >>> _SetDynamicSpdRate|UNKNOWN MESH: {params.MESH|string|lower} <<< 
			{% endif %}		
			M300 S200 P50	# emit shortest possible low-freq bloop, a low-irritation get-user-attention thing about no mesh-specific setting
		{% endif %}
		
		{% if this2.matches > 1 %}
			{% if printer["gcode_macro _gcodeproc_vars"].gcodeproc_verb_error %} 
				M118 >>> _SetDynamicSpdRate|Multiple matches on MESH: {params.MESH|string|lower} - matched {this2.matches} times <<< 
			{% endif %}		
			M300 S200 P50	# emit shortest possible low-freq bloop, a low-irritation get-user-attention thing about multiple matches
		{% endif %}
		
	{% if printer["gcode_macro _gcodeproc_vars"].gcodeproc_verb_codeflow %}  M118 >>> _SetDynamicSpdRate End <<< {% endif %}
		
	{% endif %}
