[gcode_macro _bounds_vars]
description:  vars for bounds checking

variable_bounds_alarm_duration:			1000		# ms	(3 iterations)
variable_bounds_alarm_recurse_period:	1800		# secs	(30 min)
variable_bounds_check_period:			60			# secs	(check bounds once a minute)

# @ ~35C coolant temp, flow is ~750 rpm (2mm orifice (drilled out) - 1000 rpm (1.5mm orifice (as shipped)) 
# I set ppr=1 even though this is a 3 ppr unit, using 1 to get higher resolution...
variable_h2o_flow_rpm_min:				375
variable_h2o_flow_rpm_max:				1500

# Pump is ~3000 rpm (ppr=2)
variable_h2o_pump_rpm_min:				1500
variable_h2o_pump_rpm_max:				4500

# Fan is ~2000 rpm (ppr=2)
variable_h2o_radfan_rpm_min:			1000
variable_h2o_radfan_rpm_max:			3000

# Temp is ambient to ___ (tbd once stress tested - 100 is a placeholder)
variable_h2o_temp_min:					10			# deg C
variable_h2o_temp_max:					100			# deg C

gcode:
	#there is none - for var use only...

[gcode_macro _fire_warble_alarm]
description:
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_fire_warble_alarm func_params='"{rawparams|string}"'  {% endif %}

		SET_PIN PIN=_Alarm_pin VALUE=1
		G4 P{printer["gcode_macro _bounds_vars"].bounds_alarm_duration}
		SET_PIN PIN=_Alarm_pin VALUE=0
		
		M118
		M118 ___ H2O Cooling Exceedance Alert Alarm ___
		M118 
		M118 run  _stop_bounds_alarm      to cancel Exceedance Alert Alarm once issue is resolved
		M118 or   _stop_bounds_checking   to defeat automatic H2O parameter checking entirely
		M118 and  _start_bounds_checking  to reenable automatic H2O parameter checking when appropriate
		M118
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_fire_warble_alarm {% endif %}

[delayed_gcode _recursive_bounds_alarm]
# description: runtime proc to fire a warble alarm (UBER LOUD! https://smile.amazon.com/gp/product/B079L2KBG7)
# alarm fires for a period defined by bounds_alarm_duration (see _bounds_vars above) 
# will also recurse at a period defined by bounds_alarm_recurse_period (see _bounds_vars above)
# use the following macros '_start_bounds_alarm' to initiate and '_stop_bounds_alarm' to cease the recursive firing
# added logic to only fire if printing or paused, and to cancel the recursion if 'ready'
# will likely mull on this approach with continuing the recursion or canceling same and tweak the logic in the future...
# err - changed said logic to if extruder temp > 0
initial_duration: 0

gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_recursive_bounds_alarm func_params='"{rawparams|string}"'  {% endif %}

	{% if 
			# printer.idle_timeout.state == "Printing"  or
			# printer.pause_resume.is_paused or
			printer.extruder.target > 0 
		%}

		M118 H2O cooling parameters Exceedance ALERT

		_fire_warble_alarm
		
		UPDATE_DELAYED_GCODE ID=_recursive_bounds_alarm DURATION={printer["gcode_macro _bounds_vars"].bounds_alarm_recurse_period|float}
	
	{% else %}
	# we're not printing nor paused, so must be ready [after user interaction] - so cancel the recursive alarm...

		M118 H2O cooling parameters Exceedance Alert CANCELED

		_stop_bounds_alarm
	
	{% endif %}
	
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_recursive_bounds_alarm {% endif %}

[gcode_macro _start_bounds_alarm]
description:  Alert and then set recursive reentry
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_start_bounds_alarm func_params='"{rawparams|string}"'  {% endif %}

		M118 H2O cooling parameters Exceedance ALERT

		_fire_warble_alarm
		
		UPDATE_DELAYED_GCODE ID=_recursive_bounds_alarm DURATION={printer["gcode_macro _bounds_vars"].bounds_alarm_recurse_period|float}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_start_bounds_alarm {% endif %}

[gcode_macro _stop_bounds_alarm]
description: cancels the bound exceedance alarm
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_stop_bounds_alarm func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_recursive_bounds_alarm DURATION=0

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_stop_bounds_alarm {% endif %}

[gcode_macro _emit_hho_parameters]	# cannot have combinations of numbers followed by alpha due to gcode standards
description: emits H2O Cooling Parameters and Bounds on same to console
gcode:

	{% set H2O_Flow_RPM = printer['heater_fan H2O_Flow_1K'].rpm %}
	{% set H2O_Pump_RPM = printer['heater_fan H2O_Pump_3K'].rpm %}
	{% set H2O_RadFan_RPM = printer['heater_fan H2O_RadFan_2K'].rpm %}
	{% set H2O_Temp = printer['temperature_sensor Hotend_H2O'].temperature %}

	M118
	M118 H2O Cooling Parameters:
	M118 H2O_Flow_RPM: {printer["gcode_macro _bounds_vars"].h2o_flow_rpm_min|int} <= {H2O_Flow_RPM|int} <= {printer["gcode_macro _bounds_vars"].h2o_flow_rpm_max|int}
	M118 H2O_Pump_RPM: {printer["gcode_macro _bounds_vars"].h2o_pump_rpm_min|int} <= {H2O_Pump_RPM|int} <= {printer["gcode_macro _bounds_vars"].h2o_pump_rpm_max|int}
	M118 H2O_RadFan_RPM: {printer["gcode_macro _bounds_vars"].h2o_radfan_rpm_min|int} <= {H2O_RadFan_RPM|int} <= {printer["gcode_macro _bounds_vars"].h2o_radfan_rpm_max|int}
	M118 H2O_Temp: {printer["gcode_macro _bounds_vars"].h2o_temp_min|int} <= {H2O_Temp|int} <= {printer["gcode_macro _bounds_vars"].h2o_temp_max|int}
	M118

[gcode_macro _check_bounds]
description: runtime (during printing) proc to check various parameters and initiate a pause & bound_alarm on an exceedence
# pass param REPORT=1 to get some verbosity on the parameters measured and the limits applied.
gcode:
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_check_bounds func_params='"{rawparams|string}"'  {% endif %}

	{% set H2O_Flow_RPM = printer['heater_fan H2O_Flow_1K'].rpm %}
	{% set H2O_Pump_RPM = printer['heater_fan H2O_Pump_3K'].rpm %}
	{% set H2O_RadFan_RPM = printer['heater_fan H2O_RadFan_2K'].rpm %}
	{% set H2O_Temp = printer['temperature_sensor Hotend_H2O'].temperature %}
	
#	{% if printer.idle_timeout.state == "Printing" and (

# changed to check if target temp > 0 vs. in a printing state, to help avoid cooking the HE...
# also enabling the bounds checking at printer startup vs. print_start/_resume
	{% if printer.extruder.target > 0 and (
		(H2O_Flow_RPM 	>	printer["gcode_macro _bounds_vars"].h2o_flow_rpm_max)		or 
		(H2O_Flow_RPM 	<	printer["gcode_macro _bounds_vars"].h2o_flow_rpm_min)		or
		(H2O_Pump_RPM 	>	printer["gcode_macro _bounds_vars"].h2o_pump_rpm_max)		or
		(H2O_Pump_RPM 	<	printer["gcode_macro _bounds_vars"].h2o_pump_rpm_min)		or
		(H2O_RadFan_RPM	>	printer["gcode_macro _bounds_vars"].h2o_radfan_rpm_max)		or
		(H2O_RadFan_RPM	<	printer["gcode_macro _bounds_vars"].h2o_radfan_rpm_min)		or
		(H2O_Temp		>	printer["gcode_macro _bounds_vars"].h2o_temp_max)			or
		(H2O_Temp		<	printer["gcode_macro _bounds_vars"].h2o_temp_min)		
		) %}

		M118 ... H2O cooling parameters Exceedance ALERT

		_emit_hho_parameters	# emit params and bounds to denote wtf triggered the exceedance
		_start_bounds_alarm		# aurally alert in the event away from printer/host UI
		
		M118 Pausing to enable H2O cooling parameters Exceedance resolution
		pause

	{% else %}
		# so we're either within bounds, or the extruder is set to 0, so advise no isssues and stop alarm if so enabled

		M118 ... H2O cooling parameters OK
		
		{% if params.REPORT|default(0) %}
			_emit_hho_parameters	# emit params and bounds if so trigger by a manual check
		{% endif %}
	
		_stop_bounds_alarm	# since parameters are w/in bounds, disable any alarm hiding behind a delay
		
	{% endif %}
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_check_bounds {% endif %}

[delayed_gcode check_bounds]
initial_duration: 0

gcode:

	M118 H2O cooling automatic parameter check...
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=check_bounds func_params='"{rawparams|string}"'  {% endif %}

	_check_bounds	# the check code is a proper macro to enable manual use via console (_check_bounds REPORT=1)
	
	UPDATE_DELAYED_GCODE ID=check_bounds DURATION={printer["gcode_macro _bounds_vars"].bounds_check_period|int}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=check_bounds {% endif %}

[gcode_macro _start_bounds_checking]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_start_bounds_checking func_params='"{rawparams|string}"'  {% endif %}

	_stop_bounds_alarm	# reset any prior alarm instances that may be lingering behind a delay

	M118 H2O cooling automatic parameter check Enabled
	
	UPDATE_DELAYED_GCODE ID=check_bounds DURATION=0.1	# and start the recursive bounds checking

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_start_bounds_checking {% endif %}

[gcode_macro _stop_bounds_checking]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_stop_bounds_checking func_params='"{rawparams|string}"'  {% endif %}
	
	UPDATE_DELAYED_GCODE ID=check_bounds DURATION=0

	M118 H2O cooling automatic parameter check Disabled
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_stop_bounds_checking {% endif %}

