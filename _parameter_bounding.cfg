[gcode_macro _bound_vars]
description:  vars for bounds checking

variable_bound_alarm_duration:			1000		# ms	(3 iterations)
variable_bound_alarm_recurse_period:	1800		# secs	(30 min)
variable_bounds_check_period:			60			# secs	(check bounds once a minute)

# flow is ~750 rpm (ppr=1)
variable_h2o_flow_rpm_min:				200
variable_h2o_flow_rpm_max:				1999

# Pump is ~3000 rpm (ppr=2)
variable_h2o_pump_rpm_min:				1000
variable_h2o_pump_rpm_max:				9999

# Fan is ~2000 rpm (ppr=2)
variable_h2o_radfan_rpm_min:			1000
variable_h2o_radfan_rpm_max:			9999

# Temp is ambient to ___ (tbd once stress tested - 100 is a placeholder)
variable_h2o_temp_min:					10			# deg C
variable_h2o_temp_max:					100			# deg C

gcode:
	#there is none - for var use only...

[delayed_gcode _bound_alarm]
# description: runtime proc to fire a warble alarm (UBER LOUD! https://smile.amazon.com/gp/product/B079L2KBG7)
# alarm fires for a period defined by bound_alarm_duration (see _bound_vars above) 
# will also recurse at a period defined by bound_alarm_recurse_period (see _bound_vars above)
# use the following macros '_start_bounds_alarm' to initiate and '_stop_bounds_alarm' to cease the recursive firing
# added logic to only fire if printing or paused, and to cancel the recursion if 'ready'
# will likely mull on this approach with continuing the recursion or canceling same and tweak the logic in the future...
initial_duration: 0

gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_bound_alarm func_params='"{rawparams|string}"'  {% endif %}

	{% if 
			printer.idle_timeout.state == "Printing"  or
			printer.pause_resume.is_paused
		%}

		SET_PIN PIN=_Alarm_pin VALUE=1
		G4 P{printer["gcode_macro _bound_vars"].bound_alarm_duration}
		SET_PIN PIN=_Alarm_pin VALUE=0
		
		UPDATE_DELAYED_GCODE ID=_bound_alarm DURATION={printer["gcode_macro _bound_vars"].bound_alarm_recurse_period|float}
	
	{% else %}
	# we're not printing nor paused, so must be ready [after user interaction] - so cancel the recursive alarm...
		
		UPDATE_DELAYED_GCODE ID=_bound_alarm DURATION=0
	
	{% endif %}
	
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_bound_alarm {% endif %}

[gcode_macro _start_bounds_alarm]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_start_bounds_alarm func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_bound_alarm DURATION=0.1

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_start_bounds_alarm {% endif %}

[gcode_macro _stop_bounds_alarm]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_stop_bounds_alarm func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_bound_alarm DURATION=0

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_stop_bounds_alarm {% endif %}

[gcode_macro _check_bounds]
description: runtime (during printing) proc to check various parameters and initiate a pause & bound_alarm on an exceedence
# pass param REPORT=1 to get some verbosity on the parameters measured and the limits applied.
gcode:
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_check_bounds func_params='"{rawparams|string}"'  {% endif %}

	{% set H2O_Flow_RPM = printer['heater_fan H2O_Flow_750'].rpm %}
	{% set H2O_Pump_RPM = printer['heater_fan H2O_Pump_3K'].rpm %}
	{% set H2O_RadFan_RPM = printer['heater_fan H2O_RadFan_2K'].rpm %}
	{% set H2O_Temp = printer['temperature_sensor Hotend_H2O'].temperature %}

	{% if params.REPORT|default(0) %}
		M118 H2O_Flow_RPM: {printer["gcode_macro _bound_vars"].h2o_flow_rpm_min|int} <= {H2O_Flow_RPM|int} <= {printer["gcode_macro _bound_vars"].h2o_flow_rpm_max|int}
		M118 H2O_Pump_RPM: {printer["gcode_macro _bound_vars"].h2o_pump_rpm_min|int} <= {H2O_Pump_RPM|int} <= {printer["gcode_macro _bound_vars"].h2o_pump_rpm_max|int}
		M118 H2O_RadFan_RPM: {printer["gcode_macro _bound_vars"].h2o_radfan_rpm_min|int} <= {H2O_RadFan_RPM|int} <= {printer["gcode_macro _bound_vars"].h2o_radfan_rpm_max|int}
		M118 H2O_Temp: {printer["gcode_macro _bound_vars"].h2o_temp_min|int} <= {H2O_Temp|int} <= {printer["gcode_macro _bound_vars"].h2o_temp_max|int}
	{% endif %}
	
	{% if printer.idle_timeout.state == "Printing" and (
		(H2O_Flow_RPM 	>	printer["gcode_macro _bound_vars"].h2o_flow_rpm_max)		or 
		(H2O_Flow_RPM 	<	printer["gcode_macro _bound_vars"].h2o_flow_rpm_min)		or
		(H2O_Pump_RPM 	>	printer["gcode_macro _bound_vars"].h2o_pump_rpm_max)		or
		(H2O_Pump_RPM 	<	printer["gcode_macro _bound_vars"].h2o_pump_rpm_min)		or
		(H2O_RadFan_RPM	>	printer["gcode_macro _bound_vars"].h2o_radfan_rpm_max)		or
		(H2O_RadFan_RPM	<	printer["gcode_macro _bound_vars"].h2o_radfan_rpm_min)		or
		(H2O_Temp		>	printer["gcode_macro _bound_vars"].h2o_temp_max)			or
		(H2O_Temp		<	printer["gcode_macro _bound_vars"].h2o_temp_min)		
		) %}

		_start_bounds_alarm
		pause

	{% else %}

		_stop_bounds_alarm
		
	{% endif %}
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_check_bounds {% endif %}

[delayed_gcode check_bounds]
initial_duration: 0

gcode:
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=check_bounds func_params='"{rawparams|string}"'  {% endif %}

	_check_bounds	# the check code is a proper macro to enable manual use via console (_check_bounds REPORT=1)
	
	UPDATE_DELAYED_GCODE ID=check_bounds DURATION={printer["gcode_macro _bound_vars"].bounds_check_period|int}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=check_bounds {% endif %}

[gcode_macro _start_bounds_checking]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_start_bounds_checking func_params='"{rawparams|string}"'  {% endif %}

	_stop_bounds_alarm	# reset any prior alarm instances that may be lingering behind a delay
	
	UPDATE_DELAYED_GCODE ID=check_bounds DURATION=0.1	# and start the recursive bounds checking

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_start_bounds_checking {% endif %}

[gcode_macro _stop_bounds_checking]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_stop_bounds_checking func_params='"{rawparams|string}"'  {% endif %}
	
	UPDATE_DELAYED_GCODE ID=check_bounds DURATION=0

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_stop_bounds_checking {% endif %}

