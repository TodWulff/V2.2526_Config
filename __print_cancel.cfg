#####################################################################
# 	CANCEL_PRINT + ERCF adaptations
#	largely harmonized with PRINT_END procs
#####################################################################

[delayed_gcode __print_cancel_loaded]
initial_duration: 4.501
gcode:
	_proc_start function=__print_cancel_loaded func_params='"{rawparams|string}"'  
	{% if printer["gcode_macro _printer_vars"].ptr_verb_cfgload %} 
		M118 >>> __print_cancel.cfg Loaded. <<<
	{% endif %}
	_proc_end function=__print_cancel_loaded 

[gcode_macro CANCEL_PRINT]
description: Cancel the actual running or paused print
variable_retract_temp_min:		180			 # Minimum nozzle temperature to permit a retract. Otherwise, purge will not occur.
variable_print_end_scrub:		False
rename_existing: _CANCEL_PRINT_STOCK
gcode:
	# this proc gets entered when a print is cancelled from printing OR when cancelled from pause
	# so need to logically assess moving Z before (if printing) or after XY (if paused)

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	say_wait S="Print Cancelling"

	_start_bounds_checking # re-enable automatic periodic H2O cooling parameter checks (in case canx'd by user or bounds tripped)

	######################### debug stuffs
#	{% if svv.module_debug_loaded %} _enable_trace_debug REASON='"blah"' {% endif %}
#	{% if svv.module_debug_loaded %} _enable_gmove_debug REASON='"blah"' {% endif %}
#	{% if svv.module_debug_loaded %} _enable_save_var_debug REASON='"blah"' {% endif %}

	# wondering if this is contributing to the ercf timer too close issue.?.
	M220 S100														# set feedrate percentage to default
	M221 S100														# set speed percentage to default

	_proc_start function=CANCEL_PRINT func_params='"{rawparams|string}"'  

	{% set th = printer.toolhead %}									# set context for printer.toolhead object

	{% set canx_entry_ptr_state = svv.last_ptr_state %}					# store state for conditional use later herein
	{% if printer["gcode_macro _printer_vars"].ptr_verb_debug %} M118 _____ CANCEL_PRINT | canx_entry_ptr_state: {canx_entry_ptr_state} _____ {% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_info %}
		M118 >>> Cancelling Print - svv.maxz:{svv.maxz} th.z:{th.position.z|float} <<<
	{% endif %}

	M118 CANCEL_PRINT @ S{printer.virtual_sdcard.file_position} - {(printer.virtual_sdcard.progress*100)|round(2,'common')}%: X{printer.toolhead.position.x|round(3,'common')} Y{printer.toolhead.position.y|round(3,'common')} Z{printer.toolhead.position.z|round(3,'common')}

	SAVE_VARIABLE VARIABLE=last_ptr_state VALUE='"print_canceling"'	# machine state save

	stop_pause_alarm						   						# in event canx called from pause, shut the beeping down

	SAVE_GCODE_STATE NAME=STATE_PRINT_CANX

# ok, so were cancelling a print.  if not paused, wipe and, if paused, don't wipe.
# actually, I think wiping on a cancel might be over engineering shite.  But this was 
# an effort to harmonize print cancel and print end as much as practical.
# actually, Ima overtly nix the wipe.
		
###	{% if printer.pause_resume.is_paused == true %}
###		#do not wipe
###	{% else %}
###		######################### safe anti-stringing print-canx wipe coords
###		{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}
###		{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}
###		{% set z_safe = [(th.position.z|float + 1), th.axis_maximum.z|float]|min %}
###		# {% set z_safe = [svv.maxz|float+1, th.axis_maximum.z]|min %}	# because, OAAT/SEQ context
###
###		_reset_extruder													# zero the extruder
###		{% if printer.extruder.temperature|int >= retract_temp_min|int %}
###			G1 E-0.4 F3600					  							# retract filament
###		{% else %}
###			M118 No print_end retract due to Low Temp...
###		{% endif %}
###		G0 X{x_safe} Y{y_safe} Z{z_safe} F15000							# move nozzle to remove stringing
###
###		M400															# wait for buffer to clear
###	{% endif %}

	########################  old park
	# ## {% set z_safe = [svv.maxz|float + 15, th.axis_maximum.z|float]|min|float %}
	# {% set z_safe = [(th.position.z|float + 15), th.axis_maximum.z|float]|min %}
	# G0 Z{z_safe} F6000  											# Move Up
	# G0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y} F15000		# park nozzle at center rear

	_park_head ENTRY='{canx_entry_ptr_state|string}'
	# _park_head ENTRY='print_cancelling'

	## CAUTION!!!  THIS FORCES A NOZZLE SCRUB AT THE END OF THE PRINT, WITH THE MODEL STILL ON THE BED
	# BE REALLY FUKIN CAREFUL AND KNOW WHAT IS GOING ON BEFORE ENABLING THIS...
	# And having shortened slicer's print bed enough so that no model ever gets printed on back where TH
	# could strike it during nozzle scrubs.  Also, if doing between mesh scrubs (i.e. OAAT/SEQ mode), be
	# sure to have the logic to elevate to (tallest model z-height (slicer passes maxz) before and after each.
	# Still a wip atm, but is close to being safe and robust (30Jan22).

	; {% if print_end_scrub or params.SCRUB|default(0)|int %}
		; # assumes that we're at rear center
		; G0 Z15 F1500  # drop down to pre-scrub Z15 absolute
		; CLEAN_NOZZLE DX={th.axis_maximum.x//2|float}  DY={th.axis_maximum.y|float}  DZ=15.0
	; {% endif %}

	RESTORE_GCODE_STATE NAME=STATE_PRINT_CANX

	_HOURMETER_OFF
	_PrintLED_Off

	{% if svv.module_ledeff_loaded %}
		_set_ledeff_mode CHAIN=chamber_lights	EFFECT=normal			# use LED_EFFECTS code
		_set_ledeff_mode CHAIN=lcd_lights 	EFFECT=normal			# use LED_EFFECTS code
		# _set_ledeff_mode CHAIN=ercf_lights	EFFECT=off				# use LED_EFFECTS code
		# _set_ledeff_mode CHAIN=dash_lights	EFFECT=off				# use LED_EFFECTS code
	{% else %}
		ChLts_Normal												# use Klipper Dotstar code
		LcdLts_Normal												# use Klipper Neopixel code
		# ERCFLts_off													# use Klipper Neopixel code
		# DBLts_off													# use Klipper Neopixel code
	{% endif %}

	M107															# turn off part cooling fan
	M117 Print Cancelled
	M106 S26														# forces small breeze across duct mounted chamber temp sensor

	CLEAR_PAUSE						   								# reset the fw's pause state, in case canx called from pause
	# SDCARD_RESET_FILE						   						# reset the fw's file state

	M300 P10 S3000						   							# play
	M300 P10 S2000						   							# 	descending
	M300 P10 S1000						   							#		tone
	# snd_PrintCancel

	_CANCEL_PRINT_STOCK												# chain to klipper fw print canx stuffs

	SAVE_VARIABLE VARIABLE=last_ptr_state VALUE='"print_canceled"'	# save the machine state
	SAVE_VARIABLE VARIABLE=maxz VALUE=0.0							# clear saved print height
	SAVE_VARIABLE VARIABLE=has_wipe_tower VALUE=-1					# print state initialization
	SAVE_VARIABLE VARIABLE=v2_2526_slicer_check VALUE='"NULL"'		# clear slicer check val to enable later update/check
	SAVE_VARIABLE VARIABLE=last_saved_gcode_state VALUE='"NULL"'
#	SAVE_VARIABLE VARIABLE=ercf_swaps_last_complete_print VALUE={svv.ercf_swaps}	# save current swaps
	SAVE_VARIABLE VARIABLE=ercf_swaps_last_canx_print VALUE={svv.ercf_swaps}	# save current swaps
	SAVE_VARIABLE VARIABLE=ercf_swaps VALUE=0									# clear swap

#	printer_config_backup		<-- not saving config on a canx print - it might be fubar

	# using delay here, so that FW print canx dialog can happen before this UI Prompt.
	save_variable VARIABLE=print_canx_unload  VALUE={params.UNLOAD|default(1)|int} 	# needed for _print_canx_ui_unload
	get_user_input_delay DELAY=1.0 PROMPT="Turn Heaters Off? (YES/no):" RCVR_MACRO=_print_canx_ui_cooldown TO_PERIOD=60 TO_CYCL_DEF=0 TO_RESP_DEF=YES

	_proc_end function=CANCEL_PRINT 

	######################### debug stuffs
#	{% if svv.module_debug_loaded %} _disable_save_var_debug {% endif %}	# make sure svv debug off
#	{% if svv.module_debug_loaded %} _disable_gmove_debug {% endif %}
#	{% if svv.module_debug_loaded %} _disable_trace_debug {% endif %}

[gcode_macro _print_canx_ui_cooldown]
gcode:

	_proc_start function=_print_canx_ui_cooldown func_params='"{rawparams|string}"'  

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	{% if params.UI_INPUT == YES or
		  params.UI_INPUT == 'YES' or
		  params.UI_INPUT == "YES" or
		  params.UI_INPUT == '"YES"' %}
		M118 Heaters to be turned off.
#		TURN_OFF_HEATERS
		save_variable VARIABLE=print_canx_cool  VALUE=1 	# needed for _print_canx_summary
	{% else %}
		M118 Heaters to be left on.
		save_variable VARIABLE=print_canx_cool  VALUE=0 	# needed for _print_canx_summary
	{% endif %}

	# added some logic here such that if filament isn't detected in toolhead, don't offer to unload, even if
	# unload passed. It just makes sense.  Note that it's an edge case where if filament is in bowden but not
	# at toolhead when cancelled - the user will just need to deal with those manually, ATT.
	{% if svv.module_ercf_loaded|int %}
		{% if svv.print_canx_unload and printer['filament_switch_sensor toolhead_sensor'].filament_detected != False %}
			# no need for an input prompt delay here...
			get_user_input PROMPT="Unload Filament? (YES/no):" RCVR_MACRO=_print_canx_ui_unload TO_PERIOD=30 TO_CYCL_DEF=0 TO_RESP_DEF="YES"
			# _print_canx_ui_unload chains to _print_canx_summary
		{% else %}
			{% if svv.print_canx_unload %}
				M118 Unload not offered - filament isn't detected in toolhead.
			{% endif %}
			_print_canx_summary
		{% endif %}
	{% else %}
		_print_canx_summary
	{% endif %}

	_proc_end function=_print_canx_ui_cooldown 

[gcode_macro _print_canx_ui_unload]
gcode:

	_proc_start function=_print_canx_ui_unload func_params='"{rawparams|string}"'  

	{% if params.UI_INPUT == YES or
		  params.UI_INPUT == 'YES' or
		  params.UI_INPUT == "YES" or
		  params.UI_INPUT == '"YES"' %}
		M118 Unloading Filament...
#fix: check for ercf module loaded??
		{% if printer["gcode_macro _ERCF_VAR"].clog_detection|int == 1 %}
			SET_FILAMENT_SENSOR SENSOR=encoder_sensor ENABLE=0		#nix ercf encoder_sensor ops at end so unload doesn't trip a pause.
		{% endif %}
		{% if printer['filament_switch_sensor toolhead_sensor'].filament_detected == True %}
			SET_FILAMENT_SENSOR SENSOR=toolhead_sensor ENABLE=0		#nix ercf toolhead_sensor ops at end so unload doesn't trip a pause.
			ERCF_EJECT FINAL=1
		{% else %}
			# unload here via unknown
			SET_FILAMENT_SENSOR SENSOR=toolhead_sensor ENABLE=0		#nix ercf toolhead_sensor ops at end so unload doesn't trip a pause.
			ERCF_EJECT_UNKNOW_STATE
		{% endif %}
		M118 Filament unloaded.
	{% else %}
		M118 Filament load retained.
	{% endif %}

	_print_canx_summary

	_proc_end function=_print_canx_ui_unload 

[gcode_macro _print_canx_summary]
gcode:

	_proc_start function=_print_canx_summary func_params='"{rawparams|string}"'  

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	{% if svv.print_canx_cool %}
		M141 S40														# set chamber temp to 40 to help cool it down
		TURN_OFF_HEATERS
		M118 Heaters off.
	{% else %}
		M118 Heaters remain on.
	{% endif %}

	# emit dialog in console/on lcd
	# {% if printer["gcode_macro _printer_vars"].ptr_verb_info %}
	{% if 1 %}
		{% if svv.module_ercf_loaded %}
			{% if svv.ercf_swaps_last_canx_print > 1 %}
				M118 { ">>> Print Cancelled - " ~ svv.ercf_swaps_last_canx_print ~ " swaps with " ~ svv.ercf_interactions ~ " interactions. <<<" }
				M117 Done - {svv.ercf_swaps_last_canx_print} swaps
			{% else %}
				{% if svv.ercf_interactions %}
					M118 { ">>> Print Cancelled - " ~ svv.ercf_swaps_last_canx_print ~ " swaps with 1 interactions. <<<"  }
				{% else %}
					M118 { ">>> Print Cancelled - " ~ svv.ercf_swaps_last_canx_print ~ " swaps with no interactions. <<<"  }
				{% endif %}
				M117 Done - {svv.ercf_swaps_last_canx_print} swap
			{% endif %}
		{% else %}
			M118 >>> Print Cancelled <<<
			M117 Print Cancelled
			say_wait S="Print Cancelled"

		{% endif %}
	{% endif %}

	_proc_end function=_print_canx_summary 


