#####################################################################
# 	Macros
#####################################################################

#####################################################################
# 	Printer Power Control & State Indication
#####################################################################

#--------------------------------------------------------------------

[gcode_macro testmacro]
description: testing jinja2 operations & :expressions
gcode:
	# M118 IP:{ printer.save_variables.variables.sonoff_ipaddr }

	

## These codes assume the shell_command extension is installed and 
## that shell_command.cfg is config'd to support same


#--------------------------------------------------------------------

[gcode_macro ercf_move_cart_testing]
description: move ercf cart to param C
# Example: ercf_move_cart_testing C=9
gcode:

	# need to home here if not homed
	{% if printer.save_variables.variables.ercf_selector_homed|int != 1  %}
		ERCF_HOME_SELECTOR
	{% endif %}
	
	{% set selector_axis_pos = printer["gcode_macro ERCF_VAR"].colorselector[params.C|default(0)|int]|float %}
	M118 ERCF_CART:{params.C|default(0)|int} -> {selector_axis_pos}
	MANUAL_STEPPER STEPPER=selector_stepper MOVE={selector_axis_pos}

#--------------------------------------------------------------------

[gcode_macro wcdaymode]
description: Kill IR LEDs/Deploy IR Filter
gcode:
	RUN_SHELL_COMMAND CMD=wcv2_ircut_on
	RUN_SHELL_COMMAND CMD=wcv2_irled_off
	
#--------------------------------------------------------------------

[gcode_macro wcnightmode]
description: Enable IR LEDs/Stow IR Filter
gcode:
	RUN_SHELL_COMMAND CMD=wcv2_ircut_off
	RUN_SHELL_COMMAND CMD=wcv2_irled_on
	
#--------------------------------------------------------------------

[gcode_macro printer_config_backup]
description: performs backup of local configs to the git master
gcode:
	RUN_SHELL_COMMAND CMD=backup_configs
	{ action_respond_info("Printer config backed up to git repo") }
	
#--------------------------------------------------------------------

[gcode_macro printer_config_restore]
description: Restore local configs from the git repo and restart klipper if updated
gcode:
	RUN_SHELL_COMMAND CMD=restore_configs
	{ action_respond_info("Printer config updated from git repo") }
	
#--------------------------------------------------------------------

[gcode_macro power_on_printer]
description: Power on the printer
gcode:
	RUN_SHELL_COMMAND CMD=power_on_printer
	RUN_SHELL_COMMAND CMD=restore_configs
	
#--------------------------------------------------------------------

[gcode_macro power_off_printer]
description: Power off the printer
gcode:
	RUN_SHELL_COMMAND CMD=power_off_printer

#--------------------------------------------------------------------

[gcode_macro absolute]
description: does a G90 - just for readability's sake
gcode:
	G90

#--------------------------------------------------------------------

[gcode_macro relative]
description: does a G91 - just for readability's sake
gcode:
	G91

#--------------------------------------------------------------------

[gcode_macro Z_Probe_Calibrate]
description: hmm - just found another probe thing in klickyp-probe
gcode:
	_ENSURE_QGL					# homes if needed, QGLs, rehomes Z - need to have the gantry level
	PROBE_CALIBRATE				# this calls a a klicky_probe proc

#--------------------------------------------------------------------

[gcode_macro Z_Calibrate]
description: Automatically calibrates the nozzles offset to the print surface (used in Print_Start)
gcode:
	_ENSURE_QGL					# homes if needed, QGLs, rehomes Z - need to have the gantry level
	CALIBRATE_Z					# this calls a z_calibration.py proc and uses z_calibration.cfg stuffs

#--------------------------------------------------------------------

[gcode_macro Z_EndStop_Accuracy]
description: Probe Z-Endstop accuracy at Nozzle-Endstop position
gcode:
	_ENSURE_QGL					# homes if needed, QGLs, rehomes Z - need to have the gantry level
	PROBE_Z_ACCURACY			# this calls a z_calibration.py proc and uses z_calibration.cfg stuffs

#--------------------------------------------------------------------

[gcode_macro Z_Probe_Accuracy]
description: Test and report Probe accuracy at current location, moving to 175,175 if outside of bed
gcode:
	# referencing _User_Variables macro in klickyp-probe.cfg (no wheel reinvention)
	{% set max_x = printer["gcode_macro _User_Variables"].max_bed_x %}
	{% set max_y = printer["gcode_macro _User_Variables"].max_bed_y %}
	{% set probe_offset_x = printer['configfile'].config["probe"]["x_offset"]|float %}
	{% set probe_offset_y = printer['configfile'].config["probe"]["y_offset"]|float %}

	_ENSURE_QGL					# homes if needed, QGLs, rehomes Z - need to have the gantry level

	# Protect against PROBE CALIBRATE performed from outside the bed (refs Klicky stuffs)
	{% if printer['gcode_move'].position.y > (max_y - probe_offset_y)
		  or printer['gcode_move'].position.y < probe_offset_y
		  or printer['gcode_move'].position.x > (max_x - probe_offset_x)
		  or printer['gcode_move'].position.x < probe_offset_x %}
		{ action_respond_info("PROBE_CALIBRATE requires probe above the BED - moving to bed center...") }
		absolute
		G0 X{(max_x / 2)} Y{(max_y / 2)} F15000 #mm/min .. 250mm/s - at center of bed
	{% endif%}

	# organic klipper, as modified by klickyp-probe and uses [probe] section configs for items not defined below
	PROBE_ACCURACY PROBE_SPEED=10 SAMPLES=5 SAMPLE_RETRACT_DIST=2 LIFT_SPEED=15

#--------------------------------------------------------------------

[gcode_macro system_shutdown]
description: Power off the entire system (printer AND host)
gcode:
	RUN_SHELL_COMMAND CMD=backup_configs
	RUN_SHELL_COMMAND CMD=power_off_printer
	RUN_SHELL_COMMAND CMD=system_shutdown

#--------------------------------------------------------------------

[gcode_macro _SetSlicerVar]
description: Used to runtime set slicer variables (done at slice time w/ regex post processing) contained in gcode
# added ability to call dynamic PA setting based on mesh line type
# WIP stuffs that I nix'd for now...
gcode:
 
	SAVE_VARIABLE {rawparams|lower}
	
	# added herein to allow dynamic PA setting, based on mesh type
	{% if params.VARIABLE|string == "TYPE" %}
		_SetDynamicPA MESH={params.VALUE|string|lower}
		save_variable VARIABLE='last_spd_fact' VALUE={printer.gcode_move.speed_factor|float}	# store current speed factor
	{% endif %}
	
	
	# # added herein to forcibly slow down nozzle, based on mesh type Overhang perimeter
	# {% if params.VARIABLE|string == "TYPE" and params.VALUE|string == "Overhang perimeter" %}	# if ;TYPE:Overhang perimeter
		# save_variable VARIABLE='last_spd_fact' VALUE={printer.gcode_move.speed_factor|float}	# store current speed factor
		# M220 S50																				# force a 50% slowdown
        # M300 S200 P1    																		# emit shortest possible low-freq bloop, a low-irritation get-user-attention thing
		# M118 >>> Forced a 50% speed factor due to Overhang Perimeter Line Type <<<				# advise user
		# _SetDynamicPA MESH={params.VALUE|string|lower}											# and set PA by type
	# {% elif params.VARIABLE|string == "TYPE" %}													# if ;TYPE:not Overhang perimeter
		# _SetDynamicPA MESH={params.VALUE|string|lower}											# set PA by type
		# {% if printer.gcode_move.speed_factor|float != printer.save_variables.variables.last_spd_fact|float %} #see if spd factor needs to be restored
			# M300 S1200 P1    																		# emit shortest possible low-freq bloop, a low-irritation get-user-attention thing
			# M118 >>> Restoring Speed Factor: {printer.save_variables.variables.last_spd_fact} <<<	# if so, advise user, and
			# M220 {printer.save_variables.variables.last_spd_fact|float}								# restore last saved speed factor
		# {% endif %}
	# {% endif %}

#--------------------------------------------------------------------

[delayed_gcode delayed_printer_off]
#description: Power off the printer when/if timed out
initial_duration: 0.
gcode:
  {% if printer.idle_timeout.state == "Idle" %}
 #   system_shutdown		# disabled to keep the klipper host alive...
 	RUN_SHELL_COMMAND CMD=backup_configs
	RUN_SHELL_COMMAND CMD=power_off_printer
 {% endif %}

#--------------------------------------------------------------------

##  These codes assume moonraker.conf is config'd to support same

#--------------------------------------------------------------------

[gcode_macro _PrintLED_Off]
description: Extinguish the Halo Sw Red LED
gcode:
	SET_PIN PIN=_sw_red_led VALUE=0

#--------------------------------------------------------------------

[gcode_macro _PrintLED_On]
description: Illuminate the Halo Sw Red LED
gcode:
	SET_PIN PIN=_sw_red_led VALUE=1

#--------------------------------------------------------------------

[gcode_macro _IdleLED_Off]
description: Extinguish the Halo Sw Greeen LED
gcode:
	SET_PIN PIN=_sw_grn_led VALUE=0

#--------------------------------------------------------------------

[gcode_macro _IdleLED_On]
description: Illuminate the Halo Sw Green LED
gcode:
	SET_PIN PIN=_sw_grn_led VALUE=1

#--------------------------------------------------------------------

[gcode_macro _PwrLED_Off]
description: Extinguish the Halo Sw Blue LED
gcode:
	SET_PIN PIN=_sw_blu_led VALUE=0

#--------------------------------------------------------------------

[gcode_macro _PwrLED_On]
description: Illuminate the Halo Sw Blue LED
gcode:
	SET_PIN PIN=_sw_blu_led VALUE=1

#--------------------------------------------------------------------

[gcode_macro PrintLED_Off]
gcode:
	_PrintLED_Off

#--------------------------------------------------------------------

[gcode_macro PrintLED_On]
gcode:
	_PrintLED_On

#--------------------------------------------------------------------

[gcode_macro IdleLED_Off]
gcode:
	_IdleLED_Off

#--------------------------------------------------------------------

[gcode_macro IdleLED_On]
gcode:
	_IdleLED_On

#--------------------------------------------------------------------

[gcode_macro PwrLED_Off]
gcode:
	_PwrLED_Off

#--------------------------------------------------------------------

[gcode_macro PwrLED_On]
gcode:
	_PwrLED_On

#####################################################################
# 	Manually Disable Steppers
#####################################################################

[gcode_macro disable_steppers]
description: Disable Stepper Motors
gcode:
	SAVE_VARIABLE VARIABLE=z_axis_cal VALUE=0						# since machine just started, flag a z_axis_cal is not complete
	SAVE_VARIABLE VARIABLE=ercf_selector_homed VALUE='"0"'
	SAVE_VARIABLE VARIABLE=maxz VALUE='"0.0"'						# init global var
	M18

#####################################################################
# 	Hour Meter Control
#####################################################################

[gcode_macro _HOURMETER_OFF]
description: Turn Hour Meter Off
gcode:
	SET_PIN PIN=_hourmeter VALUE=0

#--------------------------------------------------------------------

[gcode_macro _HOURMETER_ON]
description: Turn Hour Meter On
gcode:
	SET_PIN PIN=_hourmeter VALUE=1

#--------------------------------------------------------------------

[gcode_macro HOURMETER_TOGGLE]
description: Toggle Hour Meter
gcode:
	{% if printer["output_pin _hourmeter"].value == 1 %}
		_HOURMETER_OFF
	{% else %}
		_HOURMETER_ON
	{% endif %}

#--------------------------------------------------------------------

[gcode_macro save_conf]
description: Execute a Save Configuration
gcode:
	SAVE_CONFIG		# this is for runtime updates to Klipper - pushes shite to the bottom of the printer.cfg

#####################################################################
# 	Other Shite
#####################################################################

[gcode_macro clean_bed]
description: Heat bed and position head to allow cleaning of the heated print surface
gcode:

  SAVE_GCODE_STATE NAME=clean_bed
  {% if printer.heater_bed.temperature < 60 %}
	M117 Heating
	M190 S60				#wait until bed warms - helps with cleaning
  {% endif %}
  M117 Homing
  _ENSURE_HOMED					 #home
  relative					 #relative
  G0 Z75				  #move head up and out of the way
  M117 Elevating Gantry
  RESTORE_GCODE_STATE NAME=clean_bed
  M300 S1000 P100 
  M300 S1000 P100
  M117 Clean the bed...

#--------------------------------------------------------------------

# [gcode_macro G32]
# description: Do a Quad Gantry Level (QGL)
# gcode:
#	# BED_MESH_CLEAR
#	_ENSURE_QGL							# homes if needed - need to have the gantry leveled
#	G28
#	G0 X175 Y175 Z30 F3600

#--------------------------------------------------------------------

[gcode_macro M117.1]
description:  workaround for fixing a zero-based layer display
# params = L=LAYERNUM T=TOTALLAYERS
# sample slicer use: M117.1 L[layer_num] T[total_layer_count]
gcode:
	M117 Layer {(params.L|int + 1)|int}/{params.T|int}

#--------------------------------------------------------------------

[gcode_macro DO_BED_MESH]
description: Heat bed and then perform a bed mesh sequence
variable_bed_temp: 60
variable_extruder_temp: 230
gcode:
	M117 Heating...
	M140 S{bed_temp}			   # set bed final temp
	M104 S{extruder_temp}		  # set extruder final temp
	M190 S{bed_temp}			   # wait for bed final temp
	M109 S{extruder_temp}		  # wait for extruder final temp
  # _HOURMETER_ON
	_PrintLED_On
	M300
	_ENSURE_QGL							# homes if needed - need to have the gantry leveled
	BED_MESH_CALIBRATE
	G28
	M300
	M300
  # _HOURMETER_OFF
	_PrintLED_Off
	SAVE_CONFIG		# this is for runtime updates to Klipper - pushes shite to the bottom of the printer.cfg

#--------------------------------------------------------------------

[gcode_macro _ENSURE_HOMED]
description: Home only if needed - no wasted cycles/power
gcode:
	SAVE_VARIABLE VARIABLE=last_ptr_state VALUE='"checking_home"'	# machine state save
	# M118 checking_home
	{% if "z" not in printer.toolhead.homed_axes %}
		# if z is homed, xy are explicitly homed as well
		# M118 Homing
		G28
		SAVE_VARIABLE VARIABLE=z_axis_cal VALUE=0		# since homed, flag a z_axis_cal (zcal.cfg) is not complete
	{% endif %}
	SAVE_VARIABLE VARIABLE=last_ptr_state VALUE='"home_checked"'	# machine state save
	# M118 home_checked

#--------------------------------------------------------------------

[gcode_macro _ENSURE_QGL]
description: QGL only if needed - no wasted cycles/power
gcode:
	SAVE_VARIABLE VARIABLE=last_ptr_state VALUE='"checking_qgl"'	# machine state save
	# M118 checking_qgl
	_ENSURE_HOMED					# needs to be homed else qgl is not practical, if homed, no wasted cycles
	{% if not printer.quad_gantry_level.applied %} 
		# M118 QGL'g
		QUAD_GANTRY_LEVEL			# in klicky's QGL, I wrapped to include a post-level G28 Z rehome https://i.imgur.com/rMTRcaH.png
#		G28 Z						# uncomment for those without that mod to klicky's code, if so desired
		SAVE_VARIABLE VARIABLE=z_axis_cal VALUE=0		# since QGL'd, flag a z_axis_cal (zcal.cfg) is not complete
	{% endif %}
	SAVE_VARIABLE VARIABLE=last_ptr_state VALUE='"qgl_checked"'	# machine state save
	# M118 qgl_checked

#--------------------------------------------------------------------

[gcode_macro M141]
description: Implement a pseudo chamber heat control
gcode:
	# M141 S50
	{% set ch_tmp_tgt = params.S|default(0)|int %}
   SET_TEMPERATURE_FAN_TARGET temperature_fan=Exhaust target={ch_tmp_tgt} min_speed=0.0 max_speed=1.0

#--------------------------------------------------------------------

[gcode_macro corexy_gantry_speed_test]
description: ~MHz's CoreXY Speed Test [spdidx=float 1.0 to 20.0] 1 is slow, 6 is fast, >10 watchout...

# Optional Parameter(s):
# spdidx=__	float index from 1.x to 20.0 - detailed below - defaults to 1
# (reasonable parameter error trapping imputed in the code below)
# 
# The following is a todomization of the original code by 120decibell (OP).
# The hole was deep:  `Well!' thought [~MHz] to [him]self, `after such a fall as this,
# I shall think nothing of tumbling down stairs! How brave they'll all think me at home!
# Why, I wouldn't say anything about it, even if I fell off the top of the house!'
# (shamelessly raped from https://www.cs.cmu.edu/~rgs/alice-I.html)
#
# Optional Parameters enumerated above.  It is up to the user to wrap this in other code
# to instantiate the desired test context (wrt HE/Bed/Chamber temps, primairly)...
#
# This proc is intended to exercise a CoreXY A/B drive assembly in logical patterns at specific
# speeds, so users can view before/after displacement vitals enabling one to make an objective
# determination as to what practical speed limits should be applied to the printer, considering
# the physics in play at that time: TH mass, rail friction, chain/wire mass, various temps, etc.
#
# In the Voron CoreXY kinematics, there are two steppers that drive the toolhead on
# the horizontal plane.  There are three states that each of the steppers can operate in:
# Static (not moving), spinning ClockWise (cw), or spinning CounterClockwise (ccw).
# The table below enumerates the combinatings of these states for the gantry/toolhead.
# The following table assumes v2/vT B motor on LH gantry rear and A motor on RH gantry rear,
# with drive belt routing per their respective designs (Rot_ direction when viewed from top)
#
#-	RotA	RotB	Bed From	To
#0	-		-   	..toolhead static..
#1	-		cw  	lt front	rt rear
#2	-		ccw 	rt rear		lt front
#3 	cw		-   	lt rear		rt front
#4	cw		cw  	lt rear		rt rear
#5 	cw		ccw 	rt rear		rt front
#6	ccw		-   	rt front	lt rear
#7	ccw		cw  	lt front	lt rear
#8	ccw		ccw 	rt front	lt front
#
# This imputes that there are 8 dynamic states that can be in play which merit testing.  The
# code below drives the steppers in all 8 of the states enumerated in the above table by [first 
# QGL'g and homing if not so and then] moving at a prep_rate to the origin starting point.  OP
# had testing coordinates codified from edge to edge (i.e. 0,0 to 350,350).  This is cringe-
# inducing and triggering for me, so adopted a conservative buffer of 10mm on each edge, given
# the motors will be potentially driven at 'insane rates' which may impute overshoot/collision.
#
# Currently, the code is structured to drive the motors in a predetermined sequence to 
# ensure that each of the above 8 states are exercised once per iteration.  Future test
# sequencing may enable randomness, or enable the user to pass a sequencer parameter to
# allow run-time selection of multiple (or random?) sequences.  To keep the stepper motors 
# moving at the selected rate passed, the sequencing of the movements are intentionally
# structured such that there is congruity in transitioning from one leg to the next without
# repositioning the toolhead - ensures all 8 of the motor states can be exercised efficiently.
# 
# OP's code had rates (and sequencing) hard-coded @ F27000 on angular & F36000 on axial movements, a
# (3:4) ratio.  Considering Pythagoras/isosceles right triangles, equal sides of 3 nets a hypotenuse of
# 4.242...  So, to get all movements to the same temporal factors, a ratio of 3:4.24264 is to be employed 
# herein.  Interestingly (given I'm a pseudo EE), this reduces to 1:1.414213562 <-- look familiar (RMS:Peak)?
#
# spdidx parameter:  The speed index parameter can be used to pass either a 1.0>=spdidx>=20.0 as designed, or,
# if the user passes a 50.0>=spdidx>=1000.0 parameter, the code will interpret this as an angular speed in mm/x and
# derive a spdidx from same.  So passing a spdidx of 1.0 to 20.0 will impute speeds as depicted in the table
# below, whereas passing a spdidx of, as a couple examples, 350 or 550 will impute overt speeds of 350mm/sec 
# or 550mm/sec respectively.  The use of the spdidx parameter in this manner makes the tool a bit easier to use.
# 1.0>=spdidx>=20.0 (with speeds derived from maths/table below) OR 50.0>=spdidx>=1000.0 (results in that speed
# being tested directly).
#
# Speeds:
#				Feedrates					Speeds
#				mm/Minute					mm/Second
#			(Single)	(Dual)			(Single)	(Dual)
#spdidx		Angular		Axial			Angular		Axial
#---------------------------------------------------------------
# 1.0		3000		4242.640687		50			70.71067812
# 2.0		6000		8485.281374		100			141.4213562
# 3.0		9000		12727.92206		150			212.1320344
# 4.0		12000		16970.56275		200			282.8427125
# 5.0		15000		21213.20344		250			353.5533906
# 6.0		18000		25455.84412		300			424.2640687
# 7.0		21000		29698.48481		350			494.9747468
# 8.0		24000		33941.1255		400			565.6854249
# 9.0		27000		38183.76618		450			636.3961031
# 10.0		30000		42426.40687		500			707.1067812
# 11.0		33000		46669.04756		550			777.8174593
# 12.0		36000		50911.68825		600			848.5281374
# 13.0		39000		55154.32893		650			919.2388155
# 14.0		42000		59396.96962		700			989.9494937
# 15.0		45000		63639.61031		750			1060.660172
# 16.0		48000		67882.25099		800			1131.37085
# 17.0		51000		72124.89168		850			1202.081528
# 18.0		54000		76367.53237		900			1272.792206
# 19.0		57000		80610.17306		950			1343.502884
# 20.0		60000		84852.81374		1000		1414.213562
#
# "SO, this is all well and good, but wth am I to use it for?"  A good question.  Short Answer:  To see how fast you
# can move the toolhead around on the XY gantry without tossing errors, or losing track of it's positioning. 
#
# In reviewing the results (a marked-up copy here: https://i.imgur.com/kaccEpA.png), the items of interest are primairly
# those in the box, with specific focus on the X and Y (A & B) stepper values.  The goal is to use the tool to find the
# fastest rates/speeds in which the tool head can be yanked around rapidly without losing track of the tool head positioning,
# or having an error tossed because the FW/HW couldn't keep up with the demands of the Klipper host.
#
# Test at a specific spdidx (starting from lower values and working towards larger values), review results, bump speeds up,
# compare to last, keep going until a it develops where you see a divergent trend between start and stop positioning, or
# that you start getting errors being tossed.
#
# The practical limits this tool is intended to reveal are the max speeds the gantry AB servos can be driven with both no/
# minimal loss of position tracking and no error messages about the stepper drivers not being able to keep up with the demands
# from the klipper host.  An example of the latter is depicted here: https://i.imgur.com/UjGzqx3.png
#
# If one gets up to the point where they are bumping up against the ->max_velocity<- speed defined in the [printer] section,
# but are not yet seeing loss of tracking nor errors being tossed, one might want to increase said parameter in the .cfg file
# and rerun the corexy_gantry_speed_test with larger spdidx= values.  Example of exceeding speed limits in the config file:
# https://i.imgur.com/sF0vu0E.png  (I had 750mm/s limit, and was pushing at 777mm/s axial speeds).  Changing my max_velocity
# to 1000 mm/s, I was able to run the test successfully at index 11 with no issues:  https://i.imgur.com/Ih96dat.png
#
# However, running it at index 12 600/848 mm/S, the steppers started skipping and I had to emergency stop as it got fubar - lol.
# So my max_velocity is set back at 750mm/s.  I could play around with running the tests at fractional portions above 11 (i.e.
# 11.25, 11.5, 11.75, etc.), but meh, I've hit the point of diminishing returns and will never likely print this fast anyways.
# However, it is good to know that I could do so, if I desired or needed to.
#
# Of note:  I know that stepper drivers, stepper motors, and config thereof is material in all of this.  1.8 deg steppers are by
# design stronger and more capable than the 0.9 degree steppers I have on here currently.  Also, microsteps and interpolation do
# factor into max usable speeds.  When I run at 256 microsteps, things start flailing at speeds north of 500mm/s.  Changing to
# microsteps of 16, I was able to squeeze out ~50% more speed.  
#
# Further, I am pretty sure stepper driver current settings factor into this, as well as material changes to the tool-head,
# and general system topology.  With a new build, with a Pi, a stock AB and minimal wires in the chains, I was able to run at
# speeds that were North of 500mm/S and was seeing loss of position tracking (Deltas of severall hundreds depicted between the
# start and finish info displays.  With my system as it is today (external klipper host connected to the printer via a USB hub),
# and with full chains due to all the things I am doing out on the TH (different/heavier now (PCB, Accelerometer, Nozzle Cam, etc.))
# I am able to push it only so hard (I start getting errors with spdidx of 7.0 and higher (just N of 500mm/s)) and get errors before
# the drivers start to lose track of TH positioning (with microsteps of 256).  YMMV.  If you find it useful, please do let me know
# how, and what you might want to see improved with the tool.  TIA!  
#
# ~MHz

gcode:

	{% set axialrate_multiplier = 1.414166667|float  %}						# is sqrt(2) - there is no jinja2 root nor sqrt filter

	# get printer parameters
	{% set max_x = printer.toolhead.axis_maximum.x|int %}	 				# max_x from [printer]
	{% set max_y = printer.toolhead.axis_maximum.y|int %}	 				# max_y from [printer]
	{% set max_frxy = printer.toolhead.max_velocity|int * 60 %}	 		# max_velocity from [printer]

	# assert bounds on play field
	{% set min_x_test = 10|int %}											# provide 10mm buffer zone from printer limits
	{% set min_y_test = 10|int %}											# provide 10mm buffer zone from printer limits
	{% set max_x_test = max_x - 10|int %}									# provide 10mm buffer zone from printer limits
	{% set max_y_test = max_y - 10|int %}									# provide 10mm buffer zone from printer limits

	# assert origin stuffs
	{% set test_x_origin = max_x_test|int %}								# origin cordinates for test start/conclusion
	{% set test_Y_origin = max_y_test|int %}								# origin cordinates for test start/conclusion
	{% set test_preprateidx = 1|int %}										# stepper rates for test start/conclusion movements

	# init vars from passed params
	{% set spdidx = params.SPDIDX|default(4)|float %}						# defaults to spdidx 4 = 200mm/sec

	# allow for passing speeds directly as the spdidx parameter and divide by 50 to derive the spdidx
	{% if spdidx >= 50.0 %}
		{% set spdidx = (spdidx/50.0) %}
	{% endif %}

	# M118 corexy_gantry_speed_test params: {rawparams}

	# set parameter bounds
	{% set spdidx_min = 1|int %}		# 
	{% set spdidx_max = 20|int %}		# 

	# passed parameter bounds checking & error tossing
	{% if spdidx < spdidx_min or spdidx > spdidx_max %}
		{ action_respond_info("Passed spdidx parameter out of bounds - aborting") }
		{ action_raise_error("Bounds: 1.0>=spdidx>=20.0  OR  50.0>=spdidx>=1000.0") }
	{% endif %}

	# set test feedrates
	{% set test_axialfr = (spdidx*3000*axialrate_multiplier)|int %}
	{% set test_angularfr = (spdidx*3000)|int %}

	# set test feedrates
	{ action_respond_info('PrinterMaxFeedrate:\t' + max_frxy|int|string + ' mm/min  |  ' + (max_frxy/60)|int|string  + ' mm/s' ) }
	{ action_respond_info('TestAxialFeedrate:\t' + test_axialfr|int|string + ' mm/min  |  ' + (test_axialfr/60)|int|string  + ' mm/s' ) }
	{ action_respond_info('TestAngularFeedrate:\t' + test_angularfr|int|string + ' mm/min  |  ' + (test_angularfr/60)|int|string  + ' mm/s' ) }

	# check test feedrates against printer max feedrates and error out on an exceedance
	{% if test_axialfr > max_frxy %}
		{ action_raise_error("Passed spdidx parameter imputes a speed exceedance - aborting") }
	{% endif %}

	#for test dev
	{% set test_preprate = 3000|int %}							# 50mm/s speed * 60s = 3000 feedrate - benign...

	absolute															# overtly force absolute positioning
	_ENSURE_HOMED												# home if needed

	# M118 corexy_gantry_speed_test Commencing					# annunciate test commencement
	G0 X{test_x_origin} Y{test_Y_origin} F{test_preprate} 		# move to test origin
	G4 P500														# dwell on the starting line a short bit to let things settle
	GET_POSITION												# display start stats

	# Sequencing depicted here: https://i.imgur.com/Tv5Ty06.png
	# 2 sets of movements along each of the 8 test movements
	G0 X{max_x_test} Y{min_y_test} F{test_axialfr}
	G0 X{min_x_test} Y{max_y_test} F{test_angularfr}
	G0 X{max_x_test} Y{min_y_test} F{test_angularfr}
	G0 X{min_x_test} Y{min_y_test} F{test_axialfr}
	G0 X{max_x_test} Y{max_y_test} F{test_angularfr}
	G0 X{min_x_test} Y{min_y_test} F{test_angularfr}
	G0 X{min_x_test} Y{max_y_test} F{test_axialfr}
	G0 X{max_x_test} Y{max_y_test} F{test_axialfr}
	
	G0 X{min_x_test} Y{min_y_test} F{test_angularfr}
	G0 X{max_x_test} Y{max_y_test} F{test_angularfr}
	G0 X{min_x_test} Y{max_y_test} F{test_axialfr}
	G0 X{max_x_test} Y{min_y_test} F{test_angularfr}
	G0 X{min_x_test} Y{max_y_test} F{test_angularfr}
	G0 X{min_x_test} Y{min_y_test} F{test_axialfr}
	G0 X{max_x_test} Y{min_y_test} F{test_axialfr}
	G0 X{max_x_test} Y{max_y_test} F{test_axialfr}

	G0 X{test_x_origin} Y{test_Y_origin} F{test_preprate} 		# move to test origin
	G4 P500														# dwell @ the finish line a short bit to let things settle
	GET_POSITION												# display finish stats
	M118 corexy_gantry_speed_test Complete						# annunciate test conclusion
