#--------------------------------------------------------------------
# _user_interaction (UI) gcode 'module'
#--------------------------------------------------------------------

[gcode_macro _info_ui]

### TO DO:  Explain the code flow - maybe - sort of convoluted - Dev'd over the course of an 'all-nighter' session

# Relies on [Save_Variables] module - asserted above
# Makes use of M300, so comment out that line in the [delayed_gcode _ui_reminder_alarm] proc if you're not so equipped
#  - or create a dummy M300 macro that M118 emits a 'beep' :)

# all macros with executable gcode therein have been 'instrumented' - the first and last lines of each gcode block can
# be deleted.  I have these as I have an ability to trace macro code execution and display same in the console.

gcode:
# none - this macro is for module documentation only

# Primary Macro:  GET_USER_INPUT  Parameters and details follow

# PROMPT		Text to display in console as a user input prompt
# TARGET		Proc name to run after input received - UI_INPUT param passed - will need to query svv for other values
# TYPE			The type of input needed - one of these three string, integer, float
# TO_PERIOD		Period in Integer seconds to wait for user input - M300 fires at rated in _ui_vars while waiting
# TO_TARGET		Proc Name to call in the event of a user input timeout - no params passed - query svv
# BOUNDS_HI		For Integer/Float type, user input must be >=lo and <=hi
# BOUNDS_LO		 - if string type, ceiling(lo)/ceiling(hi) drive char count checks

# ALL parameters optional - read code to understand implications of relying on defaults.

# Should add a User Input macro pane, as depicted here: https://i.imgur.com/pHX6fm0.png
# Orienting it under the console pane will allow it to become intuitive

#	get_user_input	prompt="enter/click something:" # displayed on the console at macro start as a user prompt
#					type=string						# string or integer or float - for buttons use string
#					bounds_lo=1						# min # of string chars or min numercial value (int/flt)
#					bounds_hi=12					# max # of string chars or max numercial value (int/flt)
#					target=_test_show_user_input	# to accept param UI_INPUT that will be an int/flt/"string" that was input and passes sniff (simple bounds) test
#					to_period=60					# in seconds
#					to_target=repeat_get_user_input	# no params passed - use svv to see wtfe if needed

# uncommented example code follows
	get_user_input prompt="enter/click something:" type=string bounds_lo=1 bounds_hi=12 target=_test_show_user_input to_period=60 to_target=repeat_get_user_input

#--------------------------------------------------------------------

[delayed_gcode _ui_module_start]		 
#description: Sets module-specific state flags for conditional use elsewhere.
initial_duration: 0.5							# have this at 0.5s as init code in _startup_autoexec.cfg runs at 0.1s after start
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_module_start func_params='"{rawparams|string}"'  {% endif %}

	SAVE_VARIABLE VARIABLE=yes_stroked VALUE=0
	SAVE_VARIABLE VARIABLE=no_stroked VALUE=0
	SAVE_VARIABLE VARIABLE=confirm_stroked VALUE=0
	SAVE_VARIABLE VARIABLE=cancel_stroked VALUE=0
	SAVE_VARIABLE VARIABLE=user_input_string VALUE='""'
	SAVE_VARIABLE VARIABLE=user_input_integer VALUE=-9999999
	SAVE_VARIABLE VARIABLE=user_input_float VALUE=-9999999.99

	SAVE_VARIABLE VARIABLE=module_ui_loaded VALUE=1					#flag via persistent variable that this module is loaded
	SAVE_VARIABLE VARIABLE=ui_err_flag VALUE=0						#init error flag via persistent variable that this module is not in error

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_module_start {% endif %}

#--------------------------------------------------------------------

[gcode_macro _ui_vars]
description:  ui module variables

variable_ui_input_check_recurse_period:		0.5		#seconds
variable_ui_reminder_enable:				1		#bool 1/0
variable_ui_reminder_recurse_period:		30		#secs

gcode:
	# there is none - for 'gcode module' variable use only

#--------------------------------------------------------------------

[delayed_gcode _ui_reminder_alarm]
# provides a repeating alarm to alert on a requirement for user input
initial_duration: 0
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_reminder_alarm func_params='"{rawparams|string}"'  {% endif %}

	#do things here like flash leds, make noise, etc. for user attention purposes
	M300 P100 S3000
	; M300 P100 S3000
	; M300 P100 S3000

	UPDATE_DELAYED_GCODE ID=_ui_reminder_alarm DURATION={printer["gcode_macro _ui_vars"].ui_reminder_recurse_period|int}
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_reminder_alarm {% endif %}

#--------------------------------------------------------------------

[gcode_macro start_ui_reminder_alarm]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=start_ui_reminder_alarm func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_ui_reminder_alarm DURATION=0.1					# start a recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=start_ui_reminder_alarm {% endif %}

#--------------------------------------------------------------------

[gcode_macro stop_ui_reminder_alarm]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=stop_ui_reminder_alarm func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_ui_reminder_alarm DURATION=0					# stop the recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=stop_ui_reminder_alarm {% endif %}

#--------------------------------------------------------------------

[gcode_macro yes]
description: yes button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=yes func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=yes_stroked VALUE=1
	SAVE_VARIABLE VARIABLE=user_input_string VALUE='"YES"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=yes {% endif %}

#--------------------------------------------------------------------

[gcode_macro no]
description: no button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=no func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=no_stroked VALUE=1
	SAVE_VARIABLE VARIABLE=user_input_string VALUE='"NO"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=no {% endif %}

#--------------------------------------------------------------------

[gcode_macro confirm]
description: confirm button for user to stroke
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=confirm func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=confirm_stroked VALUE=1
	SAVE_VARIABLE VARIABLE=user_input_string VALUE='"CONFIRM"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=confirm {% endif %}

#--------------------------------------------------------------------

[gcode_macro cancel]
description: cancel button for user to stroke
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=cancel func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=cancel_stroked VALUE=1
	SAVE_VARIABLE VARIABLE=user_input_string VALUE='"CANCEL"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=cancel {% endif %}

#--------------------------------------------------------------------

[gcode_macro user_entry]
description: macro for user to enter integer/float numbers and QUOTED strings
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=user_entry func_params='"{rawparams|string}"'  {% endif %}

	{% set user_input_string = params.QUOTED_STRING|default("") %}
	{% set user_input_integer = params.INTEGER|default(-9999999)|int %}
	{% set user_input_float = params.FLOAT|default(-9999999.99)|float %}

	{% if user_input_string != "" %}
		SAVE_VARIABLE VARIABLE=user_input_string VALUE='"{user_input_string}"'
	{% endif %}

	{% if user_input_integer != -9999999 %}
		SAVE_VARIABLE VARIABLE=user_input_integer VALUE={user_input_integer}
	{% endif %}

	{% if user_input_float != -9999999.99 %}
		SAVE_VARIABLE VARIABLE=user_input_float VALUE={user_input_float}
	{% endif %}
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=user_entry {% endif %}

#--------------------------------------------------------------------

[delayed_gcode _user_input_timeout]
#description
initial_duration: 0
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_user_input_timeout func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	# so basically kill ui input stuff and call the timeout proc w/o parameters
	# sniff svv for called parameters if needed
	UPDATE_DELAYED_GCODE ID=_await_user_input DURATION=0
	stop_ui_reminder_alarm
	
	# this might not be needed, but just in case, stop self recursion...
	UPDATE_DELAYED_GCODE ID=_user_input_timeout DURATION=0

	# call the to target proc - codified below to default to the repeat_get_user_input macro
	{svv.ui_input_to_target}
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_user_input_timeout {% endif %}
	
#--------------------------------------------------------------------

[delayed_gcode _await_user_input]
#description
#TARGET_proc to run upon input
# can't pass dynamic parameters to delayed_gcode? so need to load target from saved variables
# had to make use of namespace workaround for in-proc flag tracking
initial_duration: 0
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_await_user_input func_params='"{rawparams|string}"'  {% endif %}

	
	{% set this = namespace(no_ui_input=1) %}	# work around for change visibility in same proc instance
	
	# this is for the case when a user enters a string that contains spaces or w/e
	{% set this2 = namespace(ui_string_flag=0) %}	# work around for change visibility in same proc instance
	
	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	{% set UI_Input = "Um, no UI_INPUT passed" %}

	# These here are checks to see if input received
	# TODO: consider using afi code to dynamically process the user input and simplify the code...
	
	{% if svv.yes_stroked %}
		{% set this.no_ui_input = 0 %}	#clear flag
		{% set UI_Input = "YES" %}
	{% endif %}

	{% if svv.no_stroked %}
		{% set this.no_ui_input = 0 %}	#clear flag
		{% set UI_Input = "NO" %}
	{% endif %}

	{% if svv.confirm_stroked %}
		{% set this.no_ui_input = 0 %}	#clear flag
		{% set UI_Input = "CONFIRM" %}
	{% endif %}

	{% if svv.cancel_stroked %}
		{% set this.no_ui_input = 0 %}	#clear flag
		{% set UI_Input = "CANCEL" %}
	{% endif %}

	{% if svv.user_input_string != "" %}
		{% set this.no_ui_input = 0 %}				#clear flag
		{% set UI_Input = svv.user_input_string %}
		{% set this2.ui_string_flag = 1 %}			#set flag to pass '"string"' vs. string (raw)	
	{% endif %}

	{% if svv.user_input_integer != -9999999 %}
		{% set this.no_ui_input = 0 %}	#clear flag
		{% set UI_Input = svv.user_input_integer %}
	{% endif %}

	{% if svv.user_input_float != -9999999.99 %}
		{% set this.no_ui_input = 0 %}	#clear flag
		{% set UI_Input = svv.user_input_float %}
	{% endif %}

	{% if this.no_ui_input == 1 %}
		
		# M118 No User Input # so continue to recurse until to is reached or user input is provided
		UPDATE_DELAYED_GCODE ID=_await_user_input DURATION={printer["gcode_macro _ui_vars"].ui_input_check_recurse_period}
	
	{% else %}
	
		# ok, we got some input so kill timeout
		UPDATE_DELAYED_GCODE ID=_user_input_timeout DURATION=0
		# this might not be needed, but just in case, stop self recursion...
		UPDATE_DELAYED_GCODE ID=_await_user_input DURATION=0
		stop_ui_reminder_alarm

		# M118 {"<BR><BR>UI: >" ~ UI_Input ~ "< being passed to target proc: " ~ svv.ui_input_target_proc ~ "<BR><BR>"}
		
		# BOUNDS CHECK 
		_validate_user_input	# this forces an 'exception' (the ui_input_timeout proc) if input is 'faulty'

		# link to a proc passed by name, passing user input as a parameter, 
		# wrapping in quotes if needed, and escaping embedded quotes
		{% if this2.ui_string_flag == 0 %}
			{svv.user_input_target_proc} UI_INPUT={UI_Input}
		{% else %} # if a string was entered, make sure to stringify it and excape any embedded quote marks
			{svv.user_input_target_proc} UI_INPUT='"{UI_Input|replace("\"","\\\"")}"' 
		{% endif %}
		
	{% endif %}
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_await_user_input {% endif %}
	
#--------------------------------------------------------------------

[gcode_macro get_user_input]
description: main macro for waiting for user input  TYPE, if passed, will determine required type
# PROMPT to display in console before user input
# TARGET proc to run after input received - said proc will need to query svv for values
# TYPE - the type of input needed - string, integer, float
# TO_PERIOD - period in seconds to wait for user input
# TO_TARGET - proc to call in the event of a user input timeout

# bounds to apply checks on user input against
# for Integer/Float type, user input must be >=low and <=high
# if string  type, ceiling(low)/ceiling(hi) drive char count checks
# BOUNDS_HI
# BOUNDS_LO

# react based on state - if idle, if printing, if paused, if error, if ...
# may need to impute a pause if not already done and in a print.?.
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=get_user_input func_params='"{rawparams|string}"'  {% endif %}

	SAVE_VARIABLE VARIABLE=ui_bad_input VALUE=0	# clear a flag

	{% set ui_input_prompt = params.PROMPT|default("Awaiting User Input") %}
	SAVE_VARIABLE VARIABLE=ui_input_prompt VALUE='"{ui_input_prompt}"'

	{% set ui_input_target_proc = params.TARGET|default("_test_show_user_input") %}
	SAVE_VARIABLE VARIABLE=ui_input_target_proc VALUE='"{ui_input_target_proc}"'

	{% set ui_input_type = params.TYPE|default("STRING") %}
	SAVE_VARIABLE VARIABLE=ui_input_type VALUE='"{ui_input_type}"'

	{% set ui_input_to_period = params.TO_PERIOD|default(30)|int %}
	SAVE_VARIABLE VARIABLE=ui_input_to_period VALUE={ui_input_to_period}

	{% set ui_input_to_target = params.TO_TARGET|default("repeat_get_user_input") %}
	SAVE_VARIABLE VARIABLE=ui_input_to_target VALUE='"{ui_input_to_target}"'

	{% set ui_input_bounds_lo = params.BOUNDS_LO|default(-999999999) %}
	SAVE_VARIABLE VARIABLE=ui_input_bounds_lo VALUE={ui_input_bounds_lo}

	{% set ui_input_bounds_hi = params.BOUNDS_HI|default(999999999) %}
	SAVE_VARIABLE VARIABLE=ui_input_bounds_hi VALUE={ui_input_bounds_hi}

	{% set ui_input_rawparams = rawparams|replace("\"","\\\"") %}
	SAVE_VARIABLE VARIABLE=ui_input_rawparams VALUE='"{ui_input_rawparams}"'

	SAVE_VARIABLE VARIABLE=yes_stroked VALUE=0
	SAVE_VARIABLE VARIABLE=no_stroked VALUE=0
	SAVE_VARIABLE VARIABLE=confirm_stroked VALUE=0
	SAVE_VARIABLE VARIABLE=cancel_stroked VALUE=0
	SAVE_VARIABLE VARIABLE=user_input_string VALUE='""'
	SAVE_VARIABLE VARIABLE=user_input_integer VALUE=-9999999
	SAVE_VARIABLE VARIABLE=user_input_float VALUE=-9999999.99
	SAVE_VARIABLE VARIABLE=user_input_target_proc	VALUE='"{ui_input_target_proc}"'
	
	M118 {"<BR>" ~ ui_input_prompt ~ "(" ~ ui_input_to_period ~ ")" ~ "<BR><BR>"}
	
	{% if printer["gcode_macro _ui_vars"].ui_reminder_enable %}
		start_ui_reminder_alarm
	{% endif %}
	
	# likely need to pause and then set timeouts for HE and Bed, or if flagged to timeout,
	
	UPDATE_DELAYED_GCODE ID=_user_input_timeout DURATION={ui_input_to_period}
	UPDATE_DELAYED_GCODE ID=_await_user_input DURATION=0.1
	
	# do we need to block or non_blocking_stall here???
	# not block or pause but rather carry on with maybe a timeout target being set???

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=get_user_input {% endif %}

[gcode_macro repeat_get_user_input]
description: default macro called in the event of a user input timeout or out of bounds user entry
# svv.ui_bad_input will alter behavior as codified herein
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=repeat_get_user_input func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	{% if svv.ui_bad_input %}
		M118 Bad Input Received - expected a {svv.ui_input_type} entry  
		
		{% if svv.ui_input_type|upper == "STRING" %}
			M118 of between {svv.ui_input_bounds_lo|round(0, 'ceil')|int} and {svv.ui_input_bounds_hi|round(0, 'ceil')|int} characters in length
		{% elif svv.ui_input_type|upper == "INTEGER" %}
			M118 between values of {svv.ui_input_bounds_lo|round(0, 'ceil')|int} and {svv.ui_input_bounds_hi|round(0, 'ceil')|int} (inclusive)
		{% else %} # float
			M118 between values of {svv.ui_input_bounds_lo|float} and {svv.ui_input_bounds_hi|float} (inclusive)
		{% endif %}
		
		M118 Please Try Again.
		# emit a requirement to wrap strings with quotation marks???  need to test and address then
	{% else %}
		M118 Input timeout - {svv.ui_input_to_period} seconds have transpired
		M118 Expecting a {svv.ui_input_type} entry  
		
		{% if svv.ui_input_type|upper == "STRING" %}
			M118 of between {svv.ui_input_bounds_lo|round(0, 'ceil')|int} and {svv.ui_input_bounds_hi|round(0, 'ceil')|int} characters in length
		{% elif svv.ui_input_type|upper == "INTEGER" %}
			M118 between values of {svv.ui_input_bounds_lo|round(0, 'ceil')|int} and {svv.ui_input_bounds_hi|round(0, 'ceil')|int} (inclusive)
		{% else %} # float
			M118 between values of {svv.ui_input_bounds_lo|float} and {svv.ui_input_bounds_hi|float} (inclusive)
		{% endif %}
		
		M118 Please Try Again.
	{% endif %}
	
	get_user_input {svv.ui_input_rawparams}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=repeat_get_user_input {% endif %}

[gcode_macro _validate_user_input]
description: does simple bounds checking based on passed type requirements
# the following user input bounds parameters are stored in svv 
# ui_input_type - def to string (used to for string inputs as well as buttons)
# ui_input_bounds_lo - for int/flt, lowest value to get, for str, lowest # of characters - def to 1
# ui_input_bounds_hi - for int/flt, highest value to get, for str, highest # of characters - def to 255
# ui_input_to_target - bad input is reacted to in the same manner as a timeout, with a flag set: svv.ui_bad_input
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_validate_user_input func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	{% if svv.ui_input_type|upper == "STRING" 
		and svv.user_input_string != ""
		and svv.user_input_string|length >= svv.ui_input_bounds_lo|round(0, 'ceil')
		and svv.user_input_string|length <= svv.ui_input_bounds_hi|round(0, 'ceil') %}
		
		# do nothing as string passes muster
	
	{% elif svv.ui_input_type|upper == "FLOAT"
		and svv.user_input_float >= svv.ui_input_bounds_lo|float
		and svv.user_input_float <= svv.ui_input_bounds_hi|float %}
		
		# do nothing as float passes muster
	
	{% elif svv.ui_input_type|upper == "INTEGER"
		and svv.user_input_integer >= svv.ui_input_bounds_lo|round(0, 'ceil')|int
		and svv.user_input_integer <= svv.ui_input_bounds_hi|round(0, 'ceil')|int %}
		
		# do nothing as integer passes muster
	
	{% else %}
		
		# if we get here, the input did not pass simple bounds checks - so initiate an 'exception'
	
		SAVE_VARIABLE VARIABLE=ui_bad_input VALUE=1						# set the flag
		UPDATE_DELAYED_GCODE ID=_user_input_timeout DURATION=0.1		# fire 'exception' code 'now'
		
	{% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_validate_user_input {% endif %}

[gcode_macro _test_show_user_input]
description: test macro to display passed user input, if any
#UI_INPUT
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_test_show_user_input func_params='"{rawparams|string}"'  {% endif %}

	{% set ui_input = params.UI_INPUT|default("no UI_INPUT passed") %}
	M118 {"You entered: " ~ ui_input}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_test_show_user_input {% endif %}









