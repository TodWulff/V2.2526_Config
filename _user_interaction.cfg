#--------------------------------------------------------------------
# _user_interaction (UI) gcode 'module'
# https://github.com/TodWulff/Klipper_UserInteraction
#--------------------------------------------------------------------

[include _ui_test.cfg]						# testing macros

[gcode_macro _info_ui_module]				# module prerequisites/documentation/notes/examples/etc.

gcode:
# This _info_ui_module macro is for module documentation ony - isn't intended to be called - no gcode here intended to be ran

# This gcode module heavily relies on [Save_Variables] module
# see: https://github.com/TodWulff/V2.2526_Config/blob/main/_persistent_variables.cfg

# This gcode module makes use of M300 and custom M300 related macros for emitting sounds, so if you're not so
# interested, or haven't a beeper on your box, comment out related lines: _ui_reminder, _annunciate_input_exception,
# and _annunciate_good_input - see: https://github.com/TodWulff/V2.2526_Config/blob/main/_m300_sounds.cfg

# This gcode module makes heavy use of the [response] module - stock M118 trapped (using rename_existing) so
# that it uses action_notification vs. FW M118 code.  This enables emission of 'special characters' that M118's
# FW code chokes on - see: https://github.com/TodWulff/V2.2526_Config/blob/main/_gcode_macros.cfg

# Throughout my configs, virtually all gcode has been 'instrumented' - the first/last set if lines in each gcode
# block can/should be deleted.  I have these as I have an ability to trace macro code execution and display same
# via console - powerful for macro development/troubleshooting but likely of little/no use to others
# see: https://github.com/TodWulff/V2.2526_Config/blob/main/_debug_macros.cfg

# Users CAN/should add a User Input macro pane, depicted: https://i.imgur.com/QVxLuVZ.png, which calls macros herein
# Orienting it under the console pane will allow it to become intuitive with a small bit of use

# Primary Macro:  GET_USER_INPUT  Parameters and related dialog follows

# Optional Parameters:
# PROMPT		Text to display in console as a user input prompt
# RCVR_MACRO	Macro name to run when VALID input received - UI_INPUT param passed to proc - if reqd, query svv for moar info
# TYPE			The TYPE of input needed - one of these three string/str, integer/int, float/flt
# BOUNDS_HI		if TYPE is float/flt, input must be >=lo and <=hi - for integer/int, input must be >=floor(lo) and <=ceiling(hi)
# BOUNDS_LO		 - if string/str TYPE, character count must be >=floor(lo) and <=ceiling(hi)
# TO_PERIOD		Period in Integer seconds to wait for user input - a reminder M300 fires at rate in _ui_vars while waiting
# EXCPT_HDLR	Macro name is called in the event of an input timeout or faulty input - no params passed - query svv...
# TO_CYCL_DEF	Defaults to -1 (disabled) >=0 integer TO_period expiration cycles to occur before TO_DEF_RESP is sent to RCVR_MACRO
# TO_RESP_DEF	if TO_CYCLES >=0, this param will be passed to RCVR_MACRO via UI_INPUT if no user input received
# RMDR_PERIOD	overrides reminder period in _ui_vars

# For string TYPE, if BOUNDS_LO is not asserted, defaults to 1
# For string TYPE, if BOUNDS_HI is not asserted, defaults to 255

# For float TYPE, if BOUNDS_LO is not asserted, defaults to -999999999.0
# For float TYPE, if BOUNDS_HI is not asserted, defaults to 999999999.0

# For integer TYPE, if BOUNDS_LO is not asserted, defaults to -999999999
# For integer TYPE, if BOUNDS_HI is not asserted, defaults to 999999999

# If additional bounds testing is desired/required, it's up to the user implementing this on their printers to craft more granular
# test and validation - by way of the RCVR_MACRO.  If I've blantantly missed something, then let me know. :)

# For optional parameters, read the code to understand implications of relying on defaults.

#	Again, ALL options are optional and default to something - defaults are as entered or noted
#	get_user_input	PROMPT="Enter or Click something:"		# displayed on the console at macro start as a user prompt
#					TYPE=STRING								# 'string' or 'integer' or 'float' - for buttons use string
#					BOUNDS_LO=1		(Int/Flt -999999999)	# min string chars or min numercial value (int/flt)
#					BOUNDS_HI=255	(Int/Flt  999999999)	# max string chars or max numercial value (int/flt)
#					RCVR_MACRO=_test_show_user_input		# to accept param UI_INPUT that will be an int/flt/"string" that was
#															# input and passes sniff (simple bounds) test
#					TO_PERIOD=120							# in seconds
#					EXCPT_HDLR=_ui_exception_handler		# no params passed - use svv to get runtime specifics if needed
#					TO_CYCL_DEF - Defaults to -1 (disabled) >=0 integer TO_period expiration cycles to occur before TO_DEF_RESP is sent to RCVR_MACRO
#					TO_RESP_DEF - if TO_CYCLES >=0, this param will be passed to RCVR_MACRO via UI_INPUT if no user input received
#					RMDR_PERIOD								# overrides reminder period in _ui_vars
#
# Example call follows:
# This looks for a user to enter a string 1-12 chars long, with a timeout of 30 secs, that forwards (via UI_INPUT param),
# the entered string to the '_test_show_user_input' macro (default if no RCVR_MACRO passed by user call)
# If a timeout happens/faulty input is detected, the _ui_timeout_watchdog/_validate_user_input macros call '_ui_exception_handler' macro
# (which is the default exception handler if no EXCPT_HDLR macro name is passed by the user call)
# being reminded every 10 seconds and after 1 requery and subsequent timeouts, "YES" will be sent as a default ui input response.
	get_user_input PROMPT="enter/click something:" TYPE=string BOUNDS_LO=1 BOUNDS_HI=12 RCVR_MACRO=_test_show_user_input TO_PERIOD=30 RMDR_PERIOD=10 EXCPT_HDLR=_ui_exception_handler TO_CYCL_DEF=1 TO_RESP_DEF="YES"

# EXCEPTION HANDLER MACRO:
# if a custom EXCPT_HDLR macro is to be instantiated, it may prove useful to consider the following:
#  - GET_USER_INPUT does the following:
#     a. initializes states and then displays the user PROMPT
#     b. sets the timeout watchdog to fire after the passed/default TO_PERIOD
#     c. puts _await_user_input into a recursive loop
#  - a single EXCPT_HDLR macro services both bad input cases as well as the time-out when waiting on user input.
#  - for timeouts the default EXCPT_HDLR macro simply recalls GET_USER_INPUT giving user another input context
#    - this approach can be altered with a custom EXCPT_HDLR macro being passed to the GET_USER_INPUT call
#  - When _await_user_input senses user input, _validate_user_input tests for TYPE and BOUNDS_HI/BOUNDS_LO compliance
#    - if input is NOT TYPE & BOUNDS_HI/BOUNDS_LO compliant, _await_user_input recalls GET_USER_INPUT so user can fix it
#    - if input IS TYPE & BOUNDS_HI/BOUNDS_LO compliant (_ui_bad_input NOT set), input is sent to RCVR_MACRO via UI_INPUT param

# If a custom EXCPT_HDLR macro is employed, when/if the get_user_input {svv.ui_input_macro_rawparams} is called to requery,
# be sure to include the helper param REQUERY=1, else the countdown to default response won't work - i.e.:
#		get_user_input {svv.ui_input_macro_rawparams} REQUERY=1
# other use of this param is done at your own risk... :)

# in most conceivable use cases, the default exception handler/validation macros should be adequate, but want to give others
# options, in the event I haven't considered something.  Either an entirely new EXCPT_HDLR can be crafted or, as demonstrated
# in _ui_test.cfg's _ui_test_exception_handler (custom EXCPT_HDLR) code runs and then calls the stock _ui_exception_handler below

# When sending UI_INPUT to RCVR_MACRO and a string is the asserted response TYPE, when performing conditional
# tests in the RCVR_MACRO, they should have the form of (note the '" pairs that surround the contents):
# https://i.imgur.com/2FOqUzQ.png

# In _ui_vars, a person implementing this can selectively enable/disable Input Prompt and/or Exception hints.  Hints are
# little descriptive blurbs as to what the code is expecting as input - one can enable hints on either the input prompt,
# or disable hints when an input exception is detected/raised.  It is suggested that it is likely best to have exception
# hints enabled, and to have the input prompt detail what sort of input is desired.  The _ui_test.cfg file has the START_DEMO
# macro that iterates through some UI input event - I used it for dev testing, it works as a demo.
# Some visual examples as it relates to the hint options that can be set in _ui_vars:

# No Hints on Exception nor Input Prompt: https://i.imgur.com/PDPOmTJ.png (likely too? terse - make prompt/preamble detailed)
# Hints on Exception only, not on Input Prompt:  https://i.imgur.com/D5Ih6hE.png (the author's preference)
# Hints on Input Prompt but not on an Exception:  https://i.imgur.com/Deo2SNr.png (leads to some noise, which may be tolerable)
# Hints on both Input Prompt and when an exception is raised:  https://i.imgur.com/mO7TfWW.png (likely redundant, imo)

#--------------------------------------------------------------------

[delayed_gcode _ui_module_start]
#description: Sets module-specific state flags for conditional use elsewhere.
initial_duration: 0.5							# have this at 0.5s as init code in _startup_autoexec.cfg runs at 0.1s after start
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_module_start func_params='"{rawparams|string}"'  {% endif %}

	_ui_clear_cache

	SAVE_VARIABLE VARIABLE=ui_input_to_cycl_def VALUE=-1			#internal decremented counter to force a default response in event of n timeouts.
	SAVE_VARIABLE VARIABLE=module_ui_loaded VALUE=1					#flag via persistent variable that this module is loaded
	SAVE_VARIABLE VARIABLE=ui_err_flag VALUE=0						#init error flag via persistent variable that this module is not in error

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_module_start {% endif %}

#--------------------------------------------------------------------

[gcode_macro _ui_vars]						# base config default variables for the _User_Interaction module
description:  ui module variables

# Defaults to be used if param not passed when GET_USER_INPUT called for:
# PROMPT, TYPE, BOUNDS_LO, BOUNDS_HI, RCVR_MACRO, TO_PERIOD, EXCPT_HDLR, TO_CYCL_DEF, TO_RESP_DEF, RMDR_PERIOD

variable_ui_input_def_param_prompt:			"Awaiting User Input:"		# Text to display in console as a user input prompt
variable_ui_input_def_param_type:			"STRING"					# The TYPE of input needed - one of these three string/str, integer/int, float/flt
variable_ui_input_def_param_bounds_lo_str:	1							# - if string/str TYPE, character count must be >=floor(lo) and <=ceiling(hi)
variable_ui_input_def_param_bounds_hi_str:	255							# if TYPE is float/flt, input must be >=lo and <=hi - for integer/int, input must be >=floor(lo) and <=ceiling(hi)
variable_ui_input_def_param_bounds_lo_num:	-999999999   				# integer or float input default max value accepted
variable_ui_input_def_param_bounds_hi_num:	999999999					# integer or float input default min value accepted
variable_ui_input_def_param_rcvr_macro:		"_test_show_user_input" 	# Macro name to run when VALID input received - UI_INPUT param passed to proc - if reqd, query svv for moar info
variable_ui_input_def_param_to_period:		120							# Period in Integer seconds to wait for user input - a reminder M300 fires at rate in _ui_vars while waiting
variable_ui_input_def_param_excpt_hdlr:		"_ui_exception_handler"		# Macro name is called in the event of an input timeout or faulty input - no params passed - query svv...
variable_ui_input_def_param_to_cycl_def:	-1							# Defaults to -1 (disabled) >=0 integer TO_period expiration cycles to occur before TO_DEF_RESP is sent to RCVR_MACRO
variable_ui_input_def_param_to_resp_def:	"NULL"						# if TO_CYCLES >=0, this param will be passed to RCVR_MACRO via UI_INPUT if no user input received
variable_ui_input_def_param_rmdr_period:	15							# reminder bleeps every n seconds - 0 will disable reminder beeps

# input scan loop iteration period (salient only when awaiting user input)
variable_ui_input_check_recurse_period:		0.5		#seconds - period between checking for input when expected - 0.5s is good.
													# more delay (slower testing iteration) and UX presents as less responsive
													# less delay and host/klipper may get needlessly tasked (admitted speculation)
# aural reminder related vars
variable_ui_reminder_enable:				1		#bool 1/0 - 0 overtly disables reminder bleeps regardless of RMDR_PERIOD param

# expected input hinting on user input promps and exceptions
variable_ui_enable_input_hints:				0		#bool 1/0
variable_ui_disable_exception_hints:		0		#bool 1/0

#ToDo - not yet implemented:
#variable_ui_force_pause_on_query:			1		#bool 1/0

# did you hear my eyes cage when they pitched through zenith on their way to nadir???
#variable_ui_he_timeout_on_input_timeout:	0		#bool 1/0
#variable_ui_hotend_timeout_period:			0		#period in secs
#variable_ui_bed_timeout_on_input_timeout:	0		#bool 1/0
#variable_ui_bed_timeout_period:			0		#period in secs

# this is a goal implementation, as it will ease module use
#variable_ui_unified_input_field:			0		#bool 1/0

#dunno if this is of value or not.  will use for a bit before deciding to embrace or forego this
#variable_ui_bypass_type_enforcement:		0		#bool 1/0
#variable_ui_bypass_bounds_enforcement:		0		#bool 1/0

gcode:
	# there is none - for 'gcode module' variable use only

#--------------------------------------------------------------------

[delayed_gcode _ui_reminder]
# provides a repeating alarm to alert on a requirement for user input
initial_duration: 0
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_reminder func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	#do things here like flash leds, make noise, etc. for user attention purposes
	M300 P100 S3000

	UPDATE_DELAYED_GCODE ID=_ui_reminder DURATION={svv.ui_input_rmdr_period}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_reminder {% endif %}

#--------------------------------------------------------------------

[gcode_macro _start_ui_reminder]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_start_ui_reminder func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	UPDATE_DELAYED_GCODE ID=_ui_reminder DURATION={svv.ui_input_rmdr_period}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_start_ui_reminder {% endif %}

#--------------------------------------------------------------------

[gcode_macro _stop_ui_reminder]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_stop_ui_reminder func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_ui_reminder DURATION=0					# stop the recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_stop_ui_reminder {% endif %}

#--------------------------------------------------------------------

[delayed_gcode _ui_timeout_watchdog]
#description
initial_duration: 0
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_timeout_watchdog func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	# we've timed out, so basically kill ui input stuff and call the exception handler proc w/o parameters
	# one can sniff svv for called parameters if needed
	_stop_ui_input_loop
	_stop_ui_timeout_watchdog
	_stop_ui_reminder

	# svv.ui_input_to_cycl_def defaults to a -1 if not passed
	{% if svv.ui_input_to_cycl_def|int >= 1 %}
		SAVE_VARIABLE VARIABLE=ui_input_to_cycl_def VALUE={svv.ui_input_to_cycl_def|int - 1}
	{% endif %}

	# send ui_input_to_resp_def to ui_input_rcvr_macro if timeout count reaches exactly 0
	{% if svv.ui_input_to_cycl_def|int == 0 %}
		# send default response
		_annunciate_good_input
		# should I better mock UI by calling processing (bypass validation as default is programmatically asserted.?.)
#fixme?
		#{svv.ui_input_rcvr_macro} UI_INPUT='"{svv.ui_input_to_resp_def|replace("\"","\\\"")}"'
		_process_user_input UI_INPUT='"{svv.ui_input_to_resp_def|replace("\"","\\\"")}"'
	{% else %}
		# call the to exception handler proc - codified below to default to the _ui_exception_handler macro
		{svv.ui_input_excpt_hdlr}
	{% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_timeout_watchdog {% endif %}

#--------------------------------------------------------------------

[gcode_macro _start_ui_timeout_watchdog]
description: Start the User Input Timeout Watchdog - param DURATION sets period
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_start_ui_timeout_watchdog func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_ui_timeout_watchdog DURATION={params.DURATION|int}					# start a recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_start_ui_timeout_watchdog {% endif %}

#--------------------------------------------------------------------

[gcode_macro _stop_ui_timeout_watchdog]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_stop_ui_timeout_watchdog func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_ui_timeout_watchdog DURATION=0					# stop the recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_stop_ui_timeout_watchdog {% endif %}

#--------------------------------------------------------------------

[delayed_gcode _await_user_input]
#description
# RCVR_MACRO = macro to run upon validated input
# can't pass dynamic parameters to delayed_gcode? so need to load RCVR_MACRO from saved variables
# had to make use of namespace workaround for in-proc flag tracking
initial_duration: 0
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_await_user_input func_params='"{rawparams|string}"'  {% endif %}

	{% set this = namespace(no_ui_input=1) %}			# work around for change visibility in same proc instance

	# this is for the case when a user enters a string that contains spaces or w/e
	{% set this2 = namespace(ui_string_flag=0) %}		# work around for change visibility in same proc instance

	{% set svv = printer.save_variables.variables %}	# set context for save_variables object

	{% set UI_Input = "Um, no UI_INPUT passed" %}

	# These here are checks to see if input received
	# TODO: consider using afi code to dynamically process the user input and simplify the code...

	# FYSA: Logically, Buttons return a STRING value, in addition to having a CLICK state flag tripped
	# this conditional set serves to limit focus to the TYPE expected - that way a stale integer/float entry
	# doesn't get associated as a STRING value and vice versa
	{% if svv.ui_input_type|upper == "STRING" %}

		{% if svv.ui_click_lt %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "LT" %}
		{% endif %}

		{% if svv.ui_click_rt %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "RT" %}
		{% endif %}

		{% if svv.ui_click_up %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "UP" %}
		{% endif %}

		{% if svv.ui_click_dn %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "DN" %}
		{% endif %}

		{% if svv.ui_click_yes %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "YES" %}
		{% endif %}

		{% if svv.ui_click_no %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "NO" %}
		{% endif %}

		{% if svv.ui_click_conf %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "CONFIRM" %}
		{% endif %}

		{% if svv.ui_click_canx %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "CANCEL" %}
		{% endif %}

		{% if svv.ui_user_input_string != "" %}
			{% set this.no_ui_input = 0 %}				#clear flag
			{% set UI_Input = svv.ui_user_input_string %}
			{% set this2.ui_string_flag = 1 %}			#set flag to pass '"string"' vs. string (raw)
		{% endif %}

	{% elif svv.ui_input_type|upper == "INTEGER" %}

		{% if svv.ui_user_input_integer != -9999999 %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = svv.ui_user_input_integer %}
		{% endif %}

	{% elif svv.ui_input_type|upper == "FLOAT" %}

		{% if svv.ui_user_input_float != -9999999.99 %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = svv.ui_user_input_float %}
		{% endif %}

	{% endif %}

	{% if this.no_ui_input == 1 %}

		# No User Input so continue to recurse until to is reached or user input is provided
		UPDATE_DELAYED_GCODE ID=_await_user_input DURATION={printer["gcode_macro _ui_vars"].ui_input_check_recurse_period}

	{% else %}

		# ok, we got some input so kill timeout & alarm
		_stop_ui_timeout_watchdog
		_stop_ui_reminder

		# validate user input for TYPE and BOUNDS_LO/BOUNDS_HI conformance
		_validate_user_input	# if input is deemed 'faulty' (type or bounds escape), this macro flags via svv.ui_bad_input
		_process_user_input UI_INPUT='{UI_Input}' IS_STRING={this2.ui_string_flag}

	{% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_await_user_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _start_ui_input_loop]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_start_ui_input_loop func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_await_user_input DURATION={printer["gcode_macro _ui_vars"].ui_input_check_recurse_period}	# start a recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_start_ui_input_loop {% endif %}

#--------------------------------------------------------------------

[gcode_macro _stop_ui_input_loop]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_stop_ui_input_loop func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_await_user_input DURATION=0					# stop the recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_stop_ui_input_loop {% endif %}

#--------------------------------------------------------------------

[gcode_macro GET_USER_INPUT_DELAY]			# <----<<< MAIN MACRO w/ Delayed Execution Implementation (param.DELAY)
description: Enables delayed utilization of GET_USER_INPUT
# save rawarams to svv.ui_input_delayed_ui_params and setup delayed_gcode to fire GET_USER_INPUT_DELAYED in param.DELAY seconds
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=GET_USER_INPUT_DELAY func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}	# set context for save_variables object
	
	{% set ui_input_delayed_ui_params = rawparams|replace("\"","\\\"") %}

	save_variable VARIABLE=ui_input_delayed_ui_params  VALUE='"{ui_input_delayed_ui_params|string}"'
	
	UPDATE_DELAYED_GCODE ID=GET_USER_INPUT_DELAYED DURATION={params.DELAY|float} # ping user for input in DELAY seconds
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=GET_USER_INPUT_DELAY {% endif %}

#--------------------------------------------------------------------

[delayed_gcode GET_USER_INPUT_DELAYED]
#description: allows for delayed utilization of GET_USER_INPUT
initial_duration: 0
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=GET_USER_INPUT_DELAYED func_params='"{rawparams|string}"'  {% endif %}
	
	#need to fetch params from svv here
	{% set svv = printer.save_variables.variables %}	# set context for save_variables object
	
	# may need to strip string encapsulation.?.
	GET_USER_INPUT {svv.ui_input_delayed_ui_params}
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=GET_USER_INPUT_DELAYED {% endif %}

#--------------------------------------------------------------------

[gcode_macro GET_USER_INPUT]				# <----<<< MAIN MACRO
description: main macro for waiting for user input - if passed, TYPE will determine required input - defaults to string of 1-255 characters
# PROMPT to display in console before user input
# TYPE - the TYPE of input needed - string/str, integer/int, float/flt
# BOUNDS_HI - for Integer/Float TYPE, user input must be >=low and <=high
# BOUNDS_LO - if string  TYPE, ceiling(low)/ceiling(hi) drive char count checks
# RCVR_MACRO proc to run after input received - said proc will need to query svv for values
# TO_PERIOD - period in seconds to wait for user input
# EXCPT_HDLR - proc to call in the event of a user input timeout

# TO_CYCL_DEF - Defaults to -1 (disabled) >0 integer TO_period expiration cycles to occur before TO_DEF_RESP is sent to RCVR_MACRO
# TO_RESP_DEF - if TO_CYCLES >0 this param will be passed to RCVR_MACRO via UI_INPUT if no user input received after TO_CYCL_DEF timeouts
# RMDR_PERIOD - period between reminder bleeps (0 disabled)

# internal parameter is used for timeout requeries - REQUERY=1 if so

#TODO:s
# react based on state - if idle, if printing, if paused, if error, if ...
# may need to impute a pause if not already done and in a print.?.

gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=get_user_input func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	_ui_clear_cache

	{% if params.REQUERY|default(0)|int == 0 %}
		# clear this decremented counter var ONLY on initial query, not automated requeries
		# this is a countdown variable to enable automatic default responses after
		# n timeouts, so its value needs to survive across requeries

		# this is the iterations to timeout before TO_RESP_DEF is sent to RCVR_MACRO
		# logic elsewhere prevents TO_RESP_DEF being sent to RCVR_MACRO if TO_CYCL_DEF <0
		{% set ui_input_to_cycl_def = params.TO_CYCL_DEF|default(printer["gcode_macro _ui_vars"].ui_input_def_param_to_cycl_def) %}
		SAVE_VARIABLE VARIABLE=ui_input_to_cycl_def VALUE={ui_input_to_cycl_def}

#fixme?  enable the following?
		# disallow a 0 value here, force to 1 if 0 is passed?
	#	{% if svv.ui_input_to_cycl_def == 0 %}
	#		SAVE_VARIABLE VARIABLE=ui_input_to_cycl_def VALUE={ui_input_to_cycl_def}
	#	{% endif %}

	{% endif %}

	# store temp targets at entry, if planning to timeout the HE/Bed
	{% set ui_entry_he_temp = svv.extruder_temp_setting %}
	{% set ui_entry_bed_temp = svv.heater_bed_temp_setting %}

	# catch klipper printer state on entry for conditionals below, when implemented.
	{% if printer.idle_timeout.state == "Printing" %}
	# force a pause
	# set timeouts for HE and Bed
	{% endif %}

	{% set ui_input_prompt = params.PROMPT|default(printer["gcode_macro _ui_vars"].ui_input_def_param_prompt) %}
	SAVE_VARIABLE VARIABLE=ui_input_prompt VALUE='"{ui_input_prompt}"'

	{% set ui_input_rcvr_macro = params.RCVR_MACRO|default(printer["gcode_macro _ui_vars"].ui_input_def_param_rcvr_macro) %}
	SAVE_VARIABLE VARIABLE=ui_input_rcvr_macro VALUE='"{ui_input_rcvr_macro}"'

	{% set ui_input_type = params.TYPE|default(printer["gcode_macro _ui_vars"].ui_input_def_param_type) %}

	# allow for abbreviations - int/integer, str/string, flt/float
	{% if ui_input_type|upper == "STR" %}
		{% set ui_input_type = "STRING" %}
	{% elif ui_input_type|upper == "INT" %}
		{% set ui_input_type = "INTEGER" %}
	{% elif ui_input_type|upper == "FLT" %}
		{% set ui_input_type = "FLOAT" %}
	{% endif %}

	SAVE_VARIABLE VARIABLE=ui_input_type VALUE='"{ui_input_type|upper}"'

	{% set ui_input_to_period = params.TO_PERIOD|default(printer["gcode_macro _ui_vars"].ui_input_def_param_to_period)|int %}
	SAVE_VARIABLE VARIABLE=ui_input_to_period VALUE={ui_input_to_period}

	{% set ui_input_excpt_hdlr = params.EXCPT_HDLR|default(printer["gcode_macro _ui_vars"].ui_input_def_param_excpt_hdlr) %}
	SAVE_VARIABLE VARIABLE=ui_input_excpt_hdlr VALUE='"{ui_input_excpt_hdlr}"'

	{% set ui_input_to_resp_def = params.TO_RESP_DEF|default(printer["gcode_macro _ui_vars"].ui_input_def_param_to_resp_def) %}
	SAVE_VARIABLE VARIABLE=ui_input_to_resp_def VALUE='"{ui_input_to_resp_def}"'

	{% if ui_input_type|upper == "STRING" %}
		{% set ui_dflt_bnd_lo = printer["gcode_macro _ui_vars"].ui_input_def_param_bounds_lo_str %}
		{% set ui_dflt_bnd_hi = printer["gcode_macro _ui_vars"].ui_input_def_param_bounds_hi_str %}
	{% else %}
		{% set ui_dflt_bnd_lo = printer["gcode_macro _ui_vars"].ui_input_def_param_bounds_lo_num %}
		{% set ui_dflt_bnd_hi = printer["gcode_macro _ui_vars"].ui_input_def_param_bounds_hi_num %}
	{% endif %}

	{% set ui_input_bounds_lo = params.BOUNDS_LO|default(ui_dflt_bnd_lo) %}
	SAVE_VARIABLE VARIABLE=ui_input_bounds_lo VALUE={ui_input_bounds_lo}

	{% set ui_input_bounds_hi = params.BOUNDS_HI|default(ui_dflt_bnd_hi) %}
	SAVE_VARIABLE VARIABLE=ui_input_bounds_hi VALUE={ui_input_bounds_hi}

	{% set ui_input_rmdr_period = params.RMDR_PERIOD|default(printer["gcode_macro _ui_vars"].ui_input_def_param_rmdr_period) %}
	SAVE_VARIABLE VARIABLE=ui_input_rmdr_period VALUE={ui_input_rmdr_period}

	{% set ui_input_macro_rawparams = rawparams|replace("\"","\\\"") %}
	SAVE_VARIABLE VARIABLE=ui_input_macro_rawparams VALUE='"{ui_input_macro_rawparams}"'

	SAVE_VARIABLE VARIABLE=ui_input_rcvr_macro	VALUE='"{ui_input_rcvr_macro}"'

	{% if printer["gcode_macro _ui_vars"].ui_enable_input_hints %}

		{% if ui_input_type|upper == "STRING" %}
			{% set hint_type = "String" %}
			{% set ui_hint = ui_input_bounds_lo|float|round(0, 'floor')|int ~ " <= length <= " ~ ui_input_bounds_hi|float|round(0, 'ceil')|int %}
		{% elif ui_input_type|upper == "INTEGER" %}
			{% set hint_type = "Integer" %}
			{% set ui_hint = ui_input_bounds_lo|float|round(0, 'floor')|int ~ " <= value <= " ~ ui_input_bounds_hi|float|round(0, 'ceil')|int %}
		{% else %} # float
			{% set hint_type = "Float" %}
			{% set ui_hint = ui_input_bounds_lo|float                       ~ " <= value <= " ~                      ui_input_bounds_hi|float %}
		{% endif %}

		{% set emission = "-------------------------------<BR>" ~
						  hint_type ~ " input needed (w/in " ~ ui_input_to_period ~ "s): " ~ ui_hint ~ "<BR>" ~
						  ui_input_prompt ~ "<BR>" ~
						  "-------------------------------<BR>" %}

		M118 {emission}

	{% else %}

		M118 { "-------------------------------<BR>" ~ ui_input_prompt ~ "<BR>-------------------------------<BR>" }

	{% endif %}

	# likely need to pause and then set timeouts for HE and Bed, or if flagged to timeout,

	_start_ui_timeout_watchdog DURATION={ui_input_to_period}	# set input timeout watchdog
	_start_ui_input_loop										# start input loop immediately

	{% if printer["gcode_macro _ui_vars"].ui_reminder_enable %}
		_start_ui_reminder
	{% endif %}

	# do we need to block or non_blocking_stall here???
	# or not block but rather carry on???

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=get_user_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _validate_user_input]
description: does simple bounds checking based on passed TYPE requirements
# the following user input bounds parameters are stored in svv
# ui_input_type - def to string (used to for string inputs as well as buttons)
# ui_input_bounds_lo - for int/flt, lowest value to get, for str, lowest # of characters - def to 1
# ui_input_bounds_hi - for int/flt, highest value to get, for str, highest # of characters - def to 255
# ui_input_excpt_hdlr - bad input is reacted to in the same manner as a timeout, with a flag set: svv.ui_bad_input
# ui_input_to_cycl_def - timeout iterations before resp_def sent to rcvr_macro
# ui_input_to_resp_def - if ui_input_to_cycl_def is > 0 then this is passed on final timeout
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_validate_user_input func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	{% if svv.ui_input_type|upper == "STRING"
		and svv.ui_user_input_string != ""
		and svv.ui_user_input_string|string|length >= svv.ui_input_bounds_lo|round(0, 'floor')
		and svv.ui_user_input_string|string|length <= svv.ui_input_bounds_hi|round(0, 'ceil') %}

		_annunciate_good_input

	{% elif svv.ui_input_type|upper == "INTEGER"
		and svv.ui_user_input_integer >= svv.ui_input_bounds_lo|round(0, 'floor')|int
		and svv.ui_user_input_integer <= svv.ui_input_bounds_hi|round(0, 'ceil')|int %}

		_annunciate_good_input

	{% elif svv.ui_input_type|upper == "FLOAT"
		and svv.ui_user_input_float >= svv.ui_input_bounds_lo|float
		and svv.ui_user_input_float <= svv.ui_input_bounds_hi|float %}

		_annunciate_good_input

	{% else %}

		# if we get here, the input did not pass simple bounds checks - so initiate an 'exception'

		# first stop stuffs so toes don't get stepped on
		_stop_ui_input_loop
		_stop_ui_timeout_watchdog
		_stop_ui_reminder

		SAVE_VARIABLE VARIABLE=ui_bad_input VALUE=1

		# call the to exception handler proc - codified below to default to the _ui_exception_handler macro
		{svv.ui_input_excpt_hdlr}

	{% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_validate_user_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _process_user_input]
description:  had to split this out of _await_user_input for svv.ui_bad_input visibility purposes
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_process_user_input func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}	# set context for save_variables object

	{% if svv.ui_bad_input != 0 %}
		# bad input received, so need to re-call get_user_input macro which
		# clears cache & resets the bad input flag) so no endless loop concerns
		get_user_input {svv.ui_input_macro_rawparams}
	{% else %}
		# input is not bad, so need to process it as good input, calling the
		# RCVR_MACRO proc passed by name, passing UI_INPUT as a parameter,
		# wrapping in quotes if needed, and escaping embedded quotes
		{% if params.IS_STRING|default(0)|int == 0 %}
			{svv.ui_input_rcvr_macro} UI_INPUT={params.UI_INPUT}
		{% else %} # if a string was entered, make sure to stringify it and escape any embedded quote marks
			{svv.ui_input_rcvr_macro} UI_INPUT='"{params.UI_INPUT|replace("\"","\\\"")}"'
		{% endif %}
	{% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_process_user_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _ui_exception_handler]			# default exception handler
description: default macro called in the event of a user input timeout or out of bounds/bad user entry
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_exception_handler func_params='"{rawparams|string}"'  {% endif %}

	_annunciate_input_exception

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	{% set exception_hint = "Exception - " %}

	{% if printer["gcode_macro _ui_vars"].ui_disable_exception_hints == 0 %}

		{% if svv.ui_bad_input != 0 %}
			{% set exception_hint = "Bad Input Received" %}
		{% else %}
			{% set exception_hint = svv.ui_input_to_period ~ "s timeout" %}
		{% endif %}

		{% set exception_hint = exception_hint ~ " - expecting a " ~ svv.ui_input_type ~ " entry " %}

		{% if svv.ui_input_type|upper == "STRING" %}
			{% set exception_hint = exception_hint ~ "of between " ~ svv.ui_input_bounds_lo|round(0, 'floor')|int ~ " and " ~ svv.ui_input_bounds_hi|round(0, 'ceil')|int ~ " char length." %}
		{% elif svv.ui_input_type|upper == "INTEGER" %}
			{% set exception_hint = exception_hint ~ "between values of " ~ svv.ui_input_bounds_lo|round(0, 'floor')|int ~ " and " ~ svv.ui_input_bounds_hi|round(0, 'ceil')|int ~ " (inclusive)." %}
		{% else %} # float
			{% set exception_hint = exception_hint ~ "between values of " ~ svv.ui_input_bounds_lo|float ~ " and " ~ svv.ui_input_bounds_hi|float ~ " (inclusive)." %}
		{% endif %}

		{% set exception_hint = exception_hint ~ "  " %}

	{% endif %}

	{% set exception_hint = exception_hint ~ "Please Try Again..." %}

	M118 { exception_hint }

	{% if svv.ui_bad_input != 0 %}
		# so we are in a bad input state, so just return and let the calling proc react to bad input
	{% else %}
		# so this is a timeout exception and not a bad input, thus not a validation exception
		# so go ahead and re-call again to give user another opportunity to give the input
		# the REQUERY=1 is important to carry over to user exception handlers so that default timeout code works like it should
		get_user_input REQUERY=1 {svv.ui_input_macro_rawparams}
	{% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_exception_handler {% endif %}

#--------------------------------------------------------------------

[gcode_macro _annunciate_good_input]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_annunciate_good_input func_params='"{rawparams|string}"'  {% endif %}

	M3002 S2000
	M3002 S3000
	M300.1

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_annunciate_good_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _annunciate_input_exception]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_annunciate_input_exception func_params='"{rawparams|string}"'  {% endif %}

	M300 P750 S350

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_annunciate_input_exception {% endif %}

#--------------------------------------------------------------------

[gcode_macro _test_show_user_input]			# default receiver macro - just echos user input to console...
description: test macro to display passed user input, if any
#UI_INPUT
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_test_show_user_input func_params='"{rawparams|string}"'  {% endif %}

	{% set ui_input = params.UI_INPUT|default("Um, NO UI_INPUT passed.!. Why? How?") %}
	M118 {"Received Input: " ~ ui_input ~ "<BR><BR>"}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_test_show_user_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _ui_clear_cache]
description: helper proc to wipe/initialize svv contents related to user input
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_clear_cache func_params='"{rawparams|string}"'  {% endif %}

	SAVE_VARIABLE VARIABLE=ui_bad_input VALUE=0

	SAVE_VARIABLE VARIABLE=ui_click_up VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_dn VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_lt VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_rt VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_yes VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_no VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_conf VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_canx VALUE=0

	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='""'
	SAVE_VARIABLE VARIABLE=ui_user_input_integer VALUE=-9999999
	SAVE_VARIABLE VARIABLE=ui_user_input_float VALUE=-9999999.99
	SAVE_VARIABLE VARIABLE=ui_user_input_raw VALUE='""'

	SAVE_VARIABLE VARIABLE=ui_input_prompt VALUE='""'
	SAVE_VARIABLE VARIABLE=ui_input_type VALUE='""'
	SAVE_VARIABLE VARIABLE=ui_input_bounds_lo VALUE=-9999999
	SAVE_VARIABLE VARIABLE=ui_input_bounds_hi VALUE=9999999
	SAVE_VARIABLE VARIABLE=ui_input_rcvr_macro VALUE='""'
	SAVE_VARIABLE VARIABLE=ui_input_to_period VALUE=0
	SAVE_VARIABLE VARIABLE=ui_input_excpt_hdlr VALUE='""'
	
##	SAVE_VARIABLE VARIABLE=ui_input_to_cycl_def VALUE=-1  Dealing with this separately as it needs to survive across requeries
	SAVE_VARIABLE VARIABLE=ui_input_to_resp_def VALUE='""'

	SAVE_VARIABLE VARIABLE=ui_input_macro_rawparams VALUE='""'
	SAVE_VARIABLE VARIABLE=ui_input_delayed_ui_params VALUE='""'


	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_clear_cache {% endif %}

#--------------------------------------------------------------------

[gcode_macro UP]							# for UI button
description: up button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=UP func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_up VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"UP"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=UP {% endif %}

#--------------------------------------------------------------------

[gcode_macro DN]							# for UI button
description: dn button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=DN func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_dn VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"DN"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=DN {% endif %}

#--------------------------------------------------------------------

[gcode_macro LT]							# for UI button
description: LT button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=LT func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_lt VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"LT"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=LT {% endif %}

#--------------------------------------------------------------------

[gcode_macro RT]							# for UI button
description: rt button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=RT func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_rt VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"RT"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=RT {% endif %}

#--------------------------------------------------------------------

[gcode_macro YES]							# for UI button
description: yes button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=YES func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_yes VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"YES"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=YES {% endif %}

#--------------------------------------------------------------------

[gcode_macro NO]							# for UI button
description: no button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=NO func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_no VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"NO"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=NO {% endif %}

#--------------------------------------------------------------------

[gcode_macro CONFIRM]						# for UI button
description: confirm button for user to stroke
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=CONFIRM func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_conf VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"CONFIRM"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=CONFIRM {% endif %}

#--------------------------------------------------------------------

[gcode_macro CANCEL]						# for UI button
description: cancel button for user to stroke
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=CANCEL func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_canx VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"CANCEL"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=CANCEL {% endif %}

#--------------------------------------------------------------------

[gcode_macro USER_ENTRY]					# for UI button
description: macro for user to enter integer/float numbers and QUOTED strings
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=USER_ENTRY func_params='"{rawparams|string}"'  {% endif %}

	{% set ui_user_input_string = params.QUOTED_STRING|default("") %}
	{% set ui_user_input_float = params.FLOAT|default(-9999999.99)|float %}
	{% set ui_user_input_integer = params.INTEGER|default(-9999999)|int %}

	{% set ui_user_input_raw = rawparams|replace("\"","\\\"") %}
	SAVE_VARIABLE VARIABLE=ui_user_input_raw VALUE='"{ui_user_input_raw}"'

	{% if ui_user_input_string != "" %}
		#SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"{ui_user_input_string|replace("\"","\\\"")}"'
		#wrappered function had a specific behavior of not saving stringified numbers as strings, by design
		#thus disabling and forcing natural behavior by calling organic klipper function directly
		_SAVE_VARIABLE_STOCK VARIABLE=ui_user_input_string VALUE='"{ui_user_input_string|replace("\"","\\\"")}"'
	{% endif %}

	{% if ui_user_input_integer != -9999999 %}
		SAVE_VARIABLE VARIABLE=ui_user_input_integer VALUE={ui_user_input_integer}
	{% endif %}

	{% if ui_user_input_float != -9999999.99 %}
		SAVE_VARIABLE VARIABLE=ui_user_input_float VALUE={ui_user_input_float}
	{% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=USER_ENTRY {% endif %}

#--------------------------------------------------------------------

[gcode_macro _null]
description: UNTESTED Dummy macro to have be a null receiver - just saves UI_INPUT to svv
gcode:
	{% set ui_last_input = params.UI_INPUT|replace("\"","\\\"") %}
	SAVE_VARIABLE VARIABLE=ui_last_input VALUE='"{ui_last_input}"'
