#--------------------------------------------------------------------
# _user_interaction (UI) gcode 'module'
#--------------------------------------------------------------------

[include _ui_test.cfg]						# testing macros

[gcode_macro _info_ui_module]				# module prerequisites/documentation/notes/examples/etc.

# Heavily relies on [Save_Variables] module
# see: https://github.com/TodWulff/V2.2526_Config/blob/main/_persistent_variables.cfg

# Makes use of M300 and some custom M300 related macros I mucked with for emitting sounds, so if you're not so
# interested, or haven't a beeper on your box, comment out related lines: _ui_reminder, _annunciate_input_exception,
# and _annunciate_good_input - see: https://github.com/TodWulff/V2.2526_Config/blob/main/_m300_sounds.cfg

# Makes heavy use of the [response] module - I've trapped the stock M118 (using rename_existing) with gcode such
# that it uses action_notification vs. FW M118 code.  This enables emission of 'special characters' that M118's
# FW code chokes on - see: https://github.com/TodWulff/V2.2526_Config/blob/main/_gcode_macros.cfg

# throughout my configs, virtually all gcode macros have been 'instrumented' - the first and last lines of each gcode
# block can be deleted.  I have these as I have an ability to trace macro code execution and display same in the
# console - quite powerful for macro development/troubleshooting but of little/no use to others, with rare exception
# see: https://github.com/TodWulff/V2.2526_Config/blob/main/_debug_macros.cfg

# Users should add a User Input macro pane, as depicted here: https://i.imgur.com/QVxLuVZ.png which calls macros herein
# Orienting it under the console pane will allow it to become intuitive with a small bit of use

gcode:
# This _info_ui_module macro is for module documentation ony - isn't intended to be called - no gcode here intended to be ran

# Primary Macro:  GET_USER_INPUT  Parameters and related dialog follows

# Optional Parameters:
# PROMPT		Text to display in console as a user input prompt
# RCVR_MACRO	Macro name to run when VALID input received - UI_INPUT param passed to proc - if reqd, query svv for moar info
# TYPE			The TYPE of input needed - one of these three string/str, integer/int, float/flt
# BOUNDS_HI		if TYPE is float/flt, input must be >=lo and <=hi - for integer/int, input must be >=floor(lo) and <=ceiling(hi)
# BOUNDS_LO		 - if string/str TYPE, character count must be >=floor(lo) and <=ceiling(hi)
# TO_PERIOD		Period in Integer seconds to wait for user input - a reminder M300 fires at rate in _ui_vars while waiting
# EXCPT_HDLR	Macro name is called in the event of an input timeout or faulty input - no params passed - query svv...

# For string TYPE, if BOUNDS_LO is not asserted, defaults to 1
# For string TYPE, if BOUNDS_HI is not asserted, defaults to 255

# For float TYPE, if BOUNDS_LO is not asserted, defaults to -999999999.0
# For float TYPE, if BOUNDS_HI is not asserted, defaults to 999999999.0

# For integer TYPE, if BOUNDS_LO is not asserted, defaults to -999999999
# For integer TYPE, if BOUNDS_HI is not asserted, defaults to 999999999

# If additional bounds testing is desired/required, it's up to the user implementing this on their printers to craft more granular
# test and validation - by way of the RCVR_MACRO.  If I've blantantly missed something, then let me know. :)

# For optional parameters, read the code to understand implications of relying on defaults.

#	Again, ALL options are optional and default to something - defaults are as entered or noted
#	get_user_input	PROMPT="Enter or Click something:"		# displayed on the console at macro start as a user prompt
#					TYPE=STRING								# 'string' or 'integer' or 'float' - for buttons use string
#					BOUNDS_LO=1		(Int/Flt -999999999)	# min string chars or min numercial value (int/flt)
#					BOUNDS_HI=255	(Int/Flt  999999999)	# max string chars or max numercial value (int/flt)
#					RCVR_MACRO=_test_show_user_input		# to accept param UI_INPUT that will be an int/flt/"string" that was 
#															# input and passes sniff (simple bounds) test
#					TO_PERIOD=120							# in seconds
#					EXCPT_HDLR=_ui_exception_handler		# no params passed - use svv to get runtime specifics if needed
#
# Example call follows:
# This looks for a user to enter a string 1-12 chars long, with a timeout of 60 secs, that forwards (via UI_INPUT param),
# the entered string to the '_test_show_user_input' macro (default if no RCVR_MACRO passed by user call)
# If a timeout happens/faulty input is detected, the _ui_timeout_watchdog/_validate_user_input macros call '_ui_exception_handler' macro
# (which is the default exception handler if no EXCPT_HDLR macro name is passed by the user call)
	get_user_input PROMPT="enter/click something:" TYPE=string BOUNDS_LO=1 BOUNDS_HI=12 RCVR_MACRO=_test_show_user_input TO_PERIOD=60 EXCPT_HDLR=_ui_exception_handler

# EXCEPTION HANDLER MACRO:
# if a custom EXCPT_HDLR macro is to be instantiated, it may prove useful to consider the following:
#  - GET_USER_INPUT does the following:
#     a. initializes states and then displays the user PROMPT
#     b. sets the timeout watchdog to fire after the passed/default TO_PERIOD
#     c. puts _await_user_input into a recursive loop
#  - a single EXCPT_HDLR macro services both bad input cases as well as the time-out when waiting on user input.
#  - for timeouts the default EXCPT_HDLR macro simply recalls GET_USER_INPUT giving user another input context
#    - this approach can be altered with a custom EXCPT_HDLR macro being passed to the GET_USER_INPUT call
#  - When _await_user_input senses user input, _validate_user_input tests for TYPE and BOUNDS_HI/BOUNDS_LO compliance
#    - if input is NOT TYPE & BOUNDS_HI/BOUNDS_LO compliant, _await_user_input recalls GET_USER_INPUT so user can fix it
#    - if input IS TYPE & BOUNDS_HI/BOUNDS_LO compliant (_ui_bad_input NOT set), input is sent to RCVR_MACRO via UI_INPUT param

# in most conceivable use cases, the default exception handler/validation macros should be adequate, but want to give others
# options, in the event I haven't considered something.  Either an entirely new EXCPT_HDLR can be crafted or, as demonstrated
# in _ui_test.cfg's _ui_test_exception_handler (custom EXCPT_HDLR) code runs and then calls the stock _ui_exception_handler below

# In _ui_vars, a person implementing this can selectively enable/disable Input Prompt and/or Exception hints.  Hints are
# little descriptive blurbs as to what the code is expecting as input - one can enable hints on either the input prompt,
# or disable hints when an input exception is detected/raised.  It is suggested that it is likely best to have exception
# hints enabled, and to have the input prompt detail what sort of input is desired.  The _ui_test.cfg file has the START_DEMO
# macro that iterates through some UI input event - I used it for dev testing, it works as a demo.
# Some visual examples as it relates to the hint options that can be set in _ui_vars:

# No Hints on Exception nor Input Prompt: https://i.imgur.com/PDPOmTJ.png (likely too? terse - make prompt/preamble detailed)
# Hints on Exception only, not on Input Prompt:  https://i.imgur.com/D5Ih6hE.png (the author's preference)
# Hints on Input Prompt but not on an Exception:  https://i.imgur.com/Deo2SNr.png (leads to some noise, which may be tolerable)
# Hints on both Input Prompt and when an exception is raised:  https://i.imgur.com/mO7TfWW.png (likely redundant, imo)

#--------------------------------------------------------------------

[delayed_gcode _ui_module_start]		
#description: Sets module-specific state flags for conditional use elsewhere.
initial_duration: 0.5							# have this at 0.5s as init code in _startup_autoexec.cfg runs at 0.1s after start
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_module_start func_params='"{rawparams|string}"'  {% endif %}

	_ui_clear_cache
	_ui_clear_test_cache
	
	SAVE_VARIABLE VARIABLE=module_ui_loaded VALUE=1					#flag via persistent variable that this module is loaded
	SAVE_VARIABLE VARIABLE=ui_err_flag VALUE=0						#init error flag via persistent variable that this module is not in error

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_module_start {% endif %}

#--------------------------------------------------------------------

[gcode_macro _ui_vars]
description:  ui module variables

# input scan loop iteration period (salient only when awaiting user input)
variable_ui_input_check_recurse_period:		0.5			#seconds - period between checking for input when expected - 0.5s is good.
														# more delay (slower testing iteration) and UX presents as less responsive
														# less delay and host/klipper may get needlessly tasked (admitted speculation)

# aural reminder related vars
variable_ui_reminder_enable:				1			#bool 1/0
variable_ui_reminder_recurse_period:		30			#secs

# expected input hinting on user input promps and exceptions
variable_ui_enable_input_hints:				0			#bool 1/0
variable_ui_disable_exception_hints:		0			#bool 1/0

# string length bounding applied in the event that get_user_input is called w/o BOUNDS_LO/BOUNDS_HI parameters provided
variable_ui_default_boundslo_string:		1			#string input default min characters accepted
variable_ui_default_boundshi_string:		255			#string input default max characters accepted

# numercial value bounding applied in the event that get_user_input is called w/o BOUNDS_LO/BOUNDS_HI parameters provided
variable_ui_default_boundslo_numercial:		-999999999	#integer or float input default min value accepted
variable_ui_default_boundshi_numercial:		999999999   #integer or float input default max value accepted

#ToDo - not yet implemented:
#variable_ui_force_pause_on_query:			1		#bool 1/0

# did you hear my eyes cage when they pitched through zenith on their way to nadir???
#variable_ui_he_timeout_on_input_timeout:	0		#bool 1/0
#variable_ui_hotend_timeout_period:			0		#period in secs
#variable_ui_bed_timeout_on_input_timeout:	0		#bool 1/0
#variable_ui_bed_timeout_period:			0		#period in secs

# this is a goal implementation, as it will ease module use)
#variable_ui_unified_input_field:			0		#bool 1/0

#dunno if this is of value or not.  will use for a bit before deciding to embrace or forego this
#variable_ui_bypass_type_enforcement:		0		#bool 1/0
#variable_ui_bypass_bounds_enforcement:		0		#bool 1/0

gcode:
	# there is none - for 'gcode module' variable use only

#--------------------------------------------------------------------


[delayed_gcode _ui_reminder]
# provides a repeating alarm to alert on a requirement for user input
initial_duration: 0
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_reminder func_params='"{rawparams|string}"'  {% endif %}

	#do things here like flash leds, make noise, etc. for user attention purposes
	M300 P100 S3000

	UPDATE_DELAYED_GCODE ID=_ui_reminder DURATION={printer["gcode_macro _ui_vars"].ui_reminder_recurse_period|int}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_reminder {% endif %}

#--------------------------------------------------------------------

[gcode_macro _start_ui_reminder]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_start_ui_reminder func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_ui_reminder DURATION={printer["gcode_macro _ui_vars"].ui_reminder_recurse_period|int}	# start a recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_start_ui_reminder {% endif %}

#--------------------------------------------------------------------

[gcode_macro _stop_ui_reminder]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_stop_ui_reminder func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_ui_reminder DURATION=0					# stop the recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_stop_ui_reminder {% endif %}

#--------------------------------------------------------------------

[delayed_gcode _ui_timeout_watchdog]
#description
initial_duration: 0
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_timeout_watchdog func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	# we've timed out, so basically kill ui input stuff and call the exception handler proc w/o parameters
	# one can sniff svv for called parameters if needed
	_stop_ui_input_loop
	_stop_ui_timeout_watchdog
	_stop_ui_reminder

	# call the to exception handler proc - codified below to default to the _ui_exception_handler macro
	{svv.ui_input_excpt_hdlr}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_timeout_watchdog {% endif %}

#--------------------------------------------------------------------

[gcode_macro _start_ui_timeout_watchdog]
description: Start the User Input Timeout Watchdog - param DURATION sets period
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_start_ui_timeout_watchdog func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_ui_timeout_watchdog DURATION={params.DURATION|int}					# start a recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_start_ui_timeout_watchdog {% endif %}

#--------------------------------------------------------------------

[gcode_macro _stop_ui_timeout_watchdog]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_stop_ui_timeout_watchdog func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_ui_timeout_watchdog DURATION=0					# stop the recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_stop_ui_timeout_watchdog {% endif %}

#--------------------------------------------------------------------


[delayed_gcode _await_user_input]
#description
# RCVR_MACRO = macro to run upon validated input
# can't pass dynamic parameters to delayed_gcode? so need to load RCVR_MACRO from saved variables
# had to make use of namespace workaround for in-proc flag tracking
initial_duration: 0
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_await_user_input func_params='"{rawparams|string}"'  {% endif %}

	{% set this = namespace(no_ui_input=1) %}			# work around for change visibility in same proc instance

	# this is for the case when a user enters a string that contains spaces or w/e
	{% set this2 = namespace(ui_string_flag=0) %}		# work around for change visibility in same proc instance

	{% set svv = printer.save_variables.variables %}	# set context for save_variables object

	{% set UI_Input = "Um, no UI_INPUT passed" %}

	# These here are checks to see if input received
	# TODO: consider using afi code to dynamically process the user input and simplify the code...

	# FYSA: Logically, Buttons return a STRING value, in addition to having a CLICK state flag tripped
	# this conditional set serves to limit focus to the TYPE expected - that way a stale integer/float entry
	# doesn't get associated as a STRING value and vice versa
	{% if svv.ui_input_type|upper == "STRING" %}

		{% if svv.ui_click_lt %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "LT" %}
		{% endif %}

		{% if svv.ui_click_rt %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "RT" %}
		{% endif %}

		{% if svv.ui_click_up %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "UP" %}
		{% endif %}

		{% if svv.ui_click_dn %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "DN" %}
		{% endif %}

		{% if svv.ui_click_yes %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "YES" %}
		{% endif %}

		{% if svv.ui_click_no %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "NO" %}
		{% endif %}

		{% if svv.ui_click_conf %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "CONFIRM" %}
		{% endif %}

		{% if svv.ui_click_canx %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "CANCEL" %}
		{% endif %}

		{% if svv.ui_user_input_string != "" %}
			{% set this.no_ui_input = 0 %}				#clear flag
			{% set UI_Input = svv.ui_user_input_string %}
			{% set this2.ui_string_flag = 1 %}			#set flag to pass '"string"' vs. string (raw)
		{% endif %}

	{% elif svv.ui_input_type|upper == "INTEGER" %} 

		{% if svv.ui_user_input_integer != -9999999 %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = svv.ui_user_input_integer %}
		{% endif %}

	{% elif svv.ui_input_type|upper == "FLOAT" %} 

		{% if svv.ui_user_input_float != -9999999.99 %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = svv.ui_user_input_float %}
		{% endif %}
		
	{% endif %}

	{% if this.no_ui_input == 1 %}

		# No User Input so continue to recurse until to is reached or user input is provided
		UPDATE_DELAYED_GCODE ID=_await_user_input DURATION={printer["gcode_macro _ui_vars"].ui_input_check_recurse_period}

	{% else %}

		# ok, we got some input so kill timeout & alarm
		_stop_ui_timeout_watchdog
		_stop_ui_reminder

		# validate user input for TYPE and BOUNDS_LO/BOUNDS_HI conformance  
		_validate_user_input	# if input is deemed 'faulty' (type or bounds escape), this macro flags via svv.ui_bad_input
		_process_user_input UI_INPUT='{UI_Input}' IS_STRING={this2.ui_string_flag}

	{% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_await_user_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _start_ui_input_loop]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_start_ui_input_loop func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_await_user_input DURATION={printer["gcode_macro _ui_vars"].ui_input_check_recurse_period}	# start a recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_start_ui_input_loop {% endif %}

#--------------------------------------------------------------------

[gcode_macro _stop_ui_input_loop]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_stop_ui_input_loop func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_await_user_input DURATION=0					# stop the recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_stop_ui_input_loop {% endif %}

#--------------------------------------------------------------------


[gcode_macro GET_USER_INPUT]				# <----<<< MAIN MACRO
description: main macro for waiting for user input - if passed, TYPE will determine required input - defaults to string of 1-255 characters
# PROMPT to display in console before user input
# RCVR_MACRO proc to run after input received - said proc will need to query svv for values
# TYPE - the TYPE of input needed - string, integer, float
# TO_PERIOD - period in seconds to wait for user input
# EXCPT_HDLR - proc to call in the event of a user input timeout

# bounds to apply checks on user input against
# for Integer/Float TYPE, user input must be >=low and <=high
# if string  TYPE, ceiling(low)/ceiling(hi) drive char count checks
# BOUNDS_HI
# BOUNDS_LO

# react based on state - if idle, if printing, if paused, if error, if ...
# may need to impute a pause if not already done and in a print.?.
gcode:
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=get_user_input func_params='"{rawparams|string}"'  {% endif %}
	
	_ui_clear_cache

	{% set ui_input_prompt = params.PROMPT|default("Awaiting User Input") %}
	SAVE_VARIABLE VARIABLE=ui_input_prompt VALUE='"{ui_input_prompt}"'

	{% set ui_input_rcvr_macro = params.RCVR_MACRO|default("_test_show_user_input") %}
	SAVE_VARIABLE VARIABLE=ui_input_rcvr_macro VALUE='"{ui_input_rcvr_macro}"'

	{% set ui_input_type = params.TYPE|default("STRING") %}
	# allow for abbreviations - int/integer, str/string, flt/float
	{% if ui_input_type|upper == "STR" %}
		{% set ui_input_type = "STRING" %}
	{% elif ui_input_type|upper == "INT" %}
		{% set ui_input_type = "INTEGER" %}
	{% elif ui_input_type|upper == "FLT" %}
		{% set ui_input_type = "FLOAT" %}
	{% endif %}
	SAVE_VARIABLE VARIABLE=ui_input_type VALUE='"{ui_input_type|upper}"'

	{% set ui_input_to_period = params.TO_PERIOD|default(120)|int %}
	SAVE_VARIABLE VARIABLE=ui_input_to_period VALUE={ui_input_to_period}

	{% set ui_input_excpt_hdlr = params.EXCPT_HDLR|default("_ui_exception_handler") %}
	SAVE_VARIABLE VARIABLE=ui_input_excpt_hdlr VALUE='"{ui_input_excpt_hdlr}"'

	{% if ui_input_type|upper == "STRING" %}
		{% set ui_dflt_bnd_lo = printer["gcode_macro _ui_vars"].ui_default_boundslo_string %}
		{% set ui_dflt_bnd_hi = printer["gcode_macro _ui_vars"].ui_default_boundshi_string %}
	{% else %}
		{% set ui_dflt_bnd_lo = printer["gcode_macro _ui_vars"].ui_default_boundslo_numercial %}
		{% set ui_dflt_bnd_hi = printer["gcode_macro _ui_vars"].ui_default_boundshi_numercial %}
	{% endif %}

	{% set ui_input_bounds_lo = params.BOUNDS_LO|default(ui_dflt_bnd_lo) %}
	SAVE_VARIABLE VARIABLE=ui_input_bounds_lo VALUE={ui_input_bounds_lo}
	
	{% set ui_input_bounds_hi = params.BOUNDS_HI|default(ui_dflt_bnd_hi) %}
	SAVE_VARIABLE VARIABLE=ui_input_bounds_hi VALUE={ui_input_bounds_hi}

	{% set ui_input_macro_rawparams = rawparams|replace("\"","\\\"") %}
	SAVE_VARIABLE VARIABLE=ui_input_macro_rawparams VALUE='"{ui_input_macro_rawparams}"'
	
	SAVE_VARIABLE VARIABLE=ui_input_rcvr_macro	VALUE='"{ui_input_rcvr_macro}"'

	{% if printer["gcode_macro _ui_vars"].ui_enable_input_hints %}

		{% if ui_input_type|upper == "STRING" %}
			{% set hint_type = "String" %}
			{% set ui_hint = ui_input_bounds_lo|float|round(0, 'floor')|int ~ " <= length <= " ~ ui_input_bounds_hi|float|round(0, 'ceil')|int %}
		{% elif ui_input_type|upper == "INTEGER" %}
			{% set hint_type = "Integer" %}
			{% set ui_hint = ui_input_bounds_lo|float|round(0, 'floor')|int ~ " <= value <= " ~ ui_input_bounds_hi|float|round(0, 'ceil')|int %}
		{% else %} # float
			{% set hint_type = "Float" %}
			{% set ui_hint = ui_input_bounds_lo|float                       ~ " <= value <= " ~                      ui_input_bounds_hi|float %}
		{% endif %}

		M118 { "-------------------------------<BR>" ~ hint_type ~ " input needed (w/in " ~ ui_input_to_period ~ "s): " ~ ui_hint ~ "<BR>" ~ ui_input_prompt ~ "<BR>-------------------------------<BR>" }

	{% else %}

		M118 { "-------------------------------<BR>" ~ ui_input_prompt ~ "<BR>-------------------------------<BR>" }

	{% endif %}

	# likely need to pause and then set timeouts for HE and Bed, or if flagged to timeout,
	
	{% if printer.idle_timeout.state == "Printing" %}
	# force a pause
	{% endif %}
	
	{% if printer.idle_timeout.state == "Printing" %}
	# set timeouts for HE and Bed
	{% endif %}

	_start_ui_timeout_watchdog DURATION={ui_input_to_period}	# set input timeout watchdog
	_start_ui_input_loop										# start input loop immediately

	{% if printer["gcode_macro _ui_vars"].ui_reminder_enable %}
		_start_ui_reminder
	{% endif %}

	# do we need to block or non_blocking_stall here???
	# or not block but rather carry on???

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=get_user_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _validate_user_input]
description: does simple bounds checking based on passed TYPE requirements
# the following user input bounds parameters are stored in svv
# ui_input_type - def to string (used to for string inputs as well as buttons)
# ui_input_bounds_lo - for int/flt, lowest value to get, for str, lowest # of characters - def to 1
# ui_input_bounds_hi - for int/flt, highest value to get, for str, highest # of characters - def to 255
# ui_input_excpt_hdlr - bad input is reacted to in the same manner as a timeout, with a flag set: svv.ui_bad_input
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_validate_user_input func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	{% if svv.ui_input_type|upper == "STRING"
		and svv.ui_user_input_string != ""
		and svv.ui_user_input_string|string|length >= svv.ui_input_bounds_lo|round(0, 'floor')
		and svv.ui_user_input_string|string|length <= svv.ui_input_bounds_hi|round(0, 'ceil') %}

		_annunciate_good_input

	{% elif svv.ui_input_type|upper == "INTEGER"
		and svv.ui_user_input_integer >= svv.ui_input_bounds_lo|round(0, 'floor')|int
		and svv.ui_user_input_integer <= svv.ui_input_bounds_hi|round(0, 'ceil')|int %}

		_annunciate_good_input

	{% elif svv.ui_input_type|upper == "FLOAT"
		and svv.ui_user_input_float >= svv.ui_input_bounds_lo|float
		and svv.ui_user_input_float <= svv.ui_input_bounds_hi|float %}

		_annunciate_good_input

	{% else %}

		# if we get here, the input did not pass simple bounds checks - so initiate an 'exception'
		
		# first stop stuffs so toes don't get stepped on
		_stop_ui_input_loop
		_stop_ui_timeout_watchdog
		_stop_ui_reminder

		SAVE_VARIABLE VARIABLE=ui_bad_input VALUE=1

		# call the to exception handler proc - codified below to default to the _ui_exception_handler macro
		{svv.ui_input_excpt_hdlr}

	{% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_validate_user_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _process_user_input]
description:  had to split this out of _await_user_input for svv.ui_bad_input visibility purposes
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_process_user_input func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}	# set context for save_variables object

	{% if svv.ui_bad_input != 0 %}
		# bad input received, so need to re-call get_user_input macro which
		# clears cache & resets the bad input flag) so no endless loop concerns
		get_user_input {svv.ui_input_macro_rawparams}
	{% else %}
		# input is not bad, so need to process it as good input, calling the
		# RCVR_MACRO proc passed by name, passing UI_INPUT as a parameter,
		# wrapping in quotes if needed, and escaping embedded quotes
		{% if params.IS_STRING|default(0)|int == 0 %}
			{svv.ui_input_rcvr_macro} UI_INPUT={params.UI_INPUT}
		{% else %} # if a string was entered, make sure to stringify it and escape any embedded quote marks
			{svv.ui_input_rcvr_macro} UI_INPUT='"{params.UI_INPUT|replace("\"","\\\"")}"'
		{% endif %}
	{% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_process_user_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _ui_exception_handler]			# default exception handler
description: default macro called in the event of a user input timeout or out of bounds/bad user entry
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_exception_handler func_params='"{rawparams|string}"'  {% endif %}
 
	_annunciate_input_exception

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object
	
	{% set exception_hint = "Exception - " %}

	{% if printer["gcode_macro _ui_vars"].ui_disable_exception_hints == 0 %}

		{% if svv.ui_bad_input != 0 %}
			{% set exception_hint = "Bad Input Received" %}
		{% else %}
			{% set exception_hint = svv.ui_input_to_period ~ "s timeout" %}
		{% endif %}
		
		{% set exception_hint = exception_hint ~ " - expecting a " ~ svv.ui_input_type ~ " entry " %}

		{% if svv.ui_input_type|upper == "STRING" %}
			{% set exception_hint = exception_hint ~ "of between " ~ svv.ui_input_bounds_lo|round(0, 'floor')|int ~ " and " ~ svv.ui_input_bounds_hi|round(0, 'ceil')|int ~ " char length." %}
		{% elif svv.ui_input_type|upper == "INTEGER" %}
			{% set exception_hint = exception_hint ~ "between values of " ~ svv.ui_input_bounds_lo|round(0, 'floor')|int ~ " and " ~ svv.ui_input_bounds_hi|round(0, 'ceil')|int ~ " (inclusive)." %}
		{% else %} # float
			{% set exception_hint = exception_hint ~ "between values of " ~ svv.ui_input_bounds_lo|float ~ " and " ~ svv.ui_input_bounds_hi|float ~ " (inclusive)." %}
		{% endif %}

		{% set exception_hint = exception_hint ~ "  " %}
	
	{% endif %}
	
	{% set exception_hint = exception_hint ~ "Please Try Again..." %}
	
	M118 { exception_hint }
	
	{% if svv.ui_bad_input != 0 %}
		# so we are in a bad input state, so just return and let the calling proc react to bad input 
	{% else %}
		# so this is a timeout exception and not a bad input, thus not a validation exception
		# so go ahead and re-call again to give user another opportunity to give the input
		get_user_input {svv.ui_input_macro_rawparams}
	{% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_exception_handler {% endif %}

#--------------------------------------------------------------------

[gcode_macro _annunciate_good_input]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_annunciate_good_input func_params='"{rawparams|string}"'  {% endif %}

	M3002 S2000
	M3002 S3000
	M300.1
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_annunciate_good_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _annunciate_input_exception]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_annunciate_input_exception func_params='"{rawparams|string}"'  {% endif %}

	M300 P750 S350
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_annunciate_input_exception {% endif %}

#--------------------------------------------------------------------

[gcode_macro _test_show_user_input]			# default receiver macro - just echos user input to console...
description: test macro to display passed user input, if any
#UI_INPUT
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_test_show_user_input func_params='"{rawparams|string}"'  {% endif %}

	{% set ui_input = params.UI_INPUT|default("Um, NO UI_INPUT passed.!. Why? How?") %}
	M118 {"Received Input: " ~ ui_input ~ "<BR><BR>"}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_test_show_user_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _ui_clear_cache]
description: helper proc to wipe/initialize svv contents related to user input
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_clear_cache func_params='"{rawparams|string}"'  {% endif %}

	SAVE_VARIABLE VARIABLE=ui_bad_input VALUE=0

	SAVE_VARIABLE VARIABLE=ui_click_up VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_dn VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_lt VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_rt VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_yes VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_no VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_conf VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_canx VALUE=0

	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='""'
	SAVE_VARIABLE VARIABLE=ui_user_input_integer VALUE=-9999999
	SAVE_VARIABLE VARIABLE=ui_user_input_float VALUE=-9999999.99
	SAVE_VARIABLE VARIABLE=ui_user_input_raw VALUE='""'

	SAVE_VARIABLE VARIABLE=ui_input_prompt VALUE='""'
	SAVE_VARIABLE VARIABLE=ui_input_type VALUE='""'
	SAVE_VARIABLE VARIABLE=ui_input_bounds_lo VALUE=-9999999
	SAVE_VARIABLE VARIABLE=ui_input_bounds_hi VALUE=9999999
	SAVE_VARIABLE VARIABLE=ui_input_rcvr_macro VALUE='""'
	SAVE_VARIABLE VARIABLE=ui_input_to_period VALUE=0
	SAVE_VARIABLE VARIABLE=ui_input_excpt_hdlr VALUE='""'
	SAVE_VARIABLE VARIABLE=ui_input_macro_rawparams VALUE='""'
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_clear_cache {% endif %}

#--------------------------------------------------------------------

[gcode_macro UP]							# for UI button
description: up button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=UP func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_up VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"UP"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=UP {% endif %}

#--------------------------------------------------------------------

[gcode_macro DN]							# for UI button
description: dn button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=DN func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_dn VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"DN"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=DN {% endif %}

#--------------------------------------------------------------------

[gcode_macro LT]							# for UI button
description: LT button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=LT func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_lt VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"LT"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=LT {% endif %}

#--------------------------------------------------------------------

[gcode_macro RT]							# for UI button
description: rt button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=RT func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_rt VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"RT"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=RT {% endif %}

#--------------------------------------------------------------------

[gcode_macro YES]							# for UI button
description: yes button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=YES func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_yes VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"YES"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=YES {% endif %}

#--------------------------------------------------------------------

[gcode_macro NO]							# for UI button
description: no button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=NO func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_no VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"NO"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=NO {% endif %}

#--------------------------------------------------------------------

[gcode_macro CONFIRM]						# for UI button
description: confirm button for user to stroke
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=CONFIRM func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_conf VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"CONFIRM"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=CONFIRM {% endif %}

#--------------------------------------------------------------------

[gcode_macro CANCEL]						# for UI button
description: cancel button for user to stroke
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=CANCEL func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_canx VALUE=1
	SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"CANCEL"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=CANCEL {% endif %}

#--------------------------------------------------------------------

[gcode_macro USER_ENTRY]					# for UI button
description: macro for user to enter integer/float numbers and QUOTED strings
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=USER_ENTRY func_params='"{rawparams|string}"'  {% endif %}

	{% set ui_user_input_string = params.QUOTED_STRING|default("") %}
	{% set ui_user_input_float = params.FLOAT|default(-9999999.99)|float %}
	{% set ui_user_input_integer = params.INTEGER|default(-9999999)|int %}
	
	{% set ui_user_input_raw = rawparams|replace("\"","\\\"") %}
	SAVE_VARIABLE VARIABLE=ui_user_input_raw VALUE='"{ui_user_input_raw}"'

	{% if ui_user_input_string != "" %}
		#SAVE_VARIABLE VARIABLE=ui_user_input_string VALUE='"{ui_user_input_string|replace("\"","\\\"")}"'
		#wrappered function had a specific behavior of not saving stringified numbers as strings, by design
		#thus disabling and forcing natural behavior by calling organic klipper function directly
		_SAVE_VARIABLE_STOCK VARIABLE=ui_user_input_string VALUE='"{ui_user_input_string|replace("\"","\\\"")}"'
	{% endif %}

	{% if ui_user_input_integer != -9999999 %}
		SAVE_VARIABLE VARIABLE=ui_user_input_integer VALUE={ui_user_input_integer}
	{% endif %}

	{% if ui_user_input_float != -9999999.99 %}
		SAVE_VARIABLE VARIABLE=ui_user_input_float VALUE={ui_user_input_float}
	{% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=USER_ENTRY {% endif %}

#--------------------------------------------------------------------

