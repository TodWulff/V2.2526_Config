#--------------------------------------------------------------------
# _user_interaction (UI) gcode 'module'
#--------------------------------------------------------------------

[include _ui_test.cfg]						# testing macros

[gcode_macro _info_ui_module]

### TO DO:  Explain the code flow - maybe - sort of convoluted - Dev'd over the course of an 'all-nighter' session

# Heavily relies on [Save_Variables] module
# see: https://github.com/TodWulff/V2.2526_Config/blob/main/_persistent_variables.cfg

# Makes use of M300 and related macros I mucked with for emitting sounds, so if you're not interested/equipped, just
#  comment out related lines in _ui_reminder, _validate_user_input. _annunciate_good_input
# see: https://github.com/TodWulff/V2.2526_Config/blob/main/_m300_sounds.cfg

# Makes heavy use of the [response] module.  I've wrapped the M118 (rename existing) with gcode such that it used
# action_notification vs. FW code.  This enables emission of 'special characters' that M118's FW code chokes on.
# see: https://github.com/TodWulff/V2.2526_Config/blob/main/_gcode_macros.cfg

# In my repo, most macros with gcode therein have been 'instrumented' - the first and last lines of each gcode block can
# be deleted.  I have these as I have an ability to trace macro code execution and display same in the console.
# see: https://github.com/TodWulff/V2.2526_Config/blob/main/_debug_macros.cfg

# Users should add a User Input macro pane, as depicted here: https://i.imgur.com/QVxLuVZ.png which calls macros herein
# Orienting it under the console pane will allow it to become intuitive:

gcode:
# none - this macro is for module documentation only

# Primary Macro:  GET_USER_INPUT  Parameters and details follow

# PROMPT		Text to display in console as a user input prompt
# RCVR_MACRO	Proc name to run after input received - UI_INPUT param passed to proc - if reqd, query svv for other values
# TYPE			The TYPE of input needed - one of these three string, integer, float
# TO_PERIOD		Period in Integer seconds to wait for user input - M300 fires at rated in _ui_vars while waiting
# EXCPT_HDLR	Proc Name to call in the event of a user input timeout - no params passed - query svv
# BOUNDS_HI		For Integer/Float TYPE, user input must be >=lo and <=hi
# BOUNDS_LO		 - if string TYPE, ceiling(lo)/ceiling(hi) drive char count checks

# For optional parameters, read code to understand implications of relying on defaults.

#	Again, ALL options are optional and default to something - defaults are as entered or noted
#	get_user_input	PROMPT="Enter or Click something:"		# displayed on the console at macro start as a user prompt
#					TYPE=STRING								# 'string' or 'integer' or 'float' - for buttons use string
#					BOUNDS_LO=1		(Int/Flt -999999999)	# min string chars or min numercial value (int/flt)
#					BOUNDS_HI=255	(Int/Flt  999999999)	# max string chars or max numercial value (int/flt)
#					RCVR_MACRO=_test_show_user_input		# to accept param UI_INPUT that will be an int/flt/"string" that was 
#															# input and passes sniff (simple bounds) test
#					TO_PERIOD=120							# in seconds
#					EXCPT_HDLR=_ui_exception_handler		# no params passed - use svv to get runtime specifics if needed
#
# Example call follows:
# This looks for a user to enter a string 1-12 chars long, with a timeout of 60 secs, that forwards (via UI_INPUT param),
# the entered string to the '_test_show_user_input' macro (default if no RCVR_MACRO passed by user call)
# If a timeout happens/faulty input is detected, the _ui_timeout_watchdog/_validate_user_input macros call '_ui_exception_handler' macro
# (which is the default exception handler if no EXCPT_HDLR macro name is passed by the user call)
	get_user_input PROMPT="enter/click something:" TYPE=string BOUNDS_LO=1 BOUNDS_HI=12 RCVR_MACRO=_test_show_user_input TO_PERIOD=60 EXCPT_HDLR=_ui_exception_handler

#--------------------------------------------------------------------


[delayed_gcode _ui_module_start]		
#description: Sets module-specific state flags for conditional use elsewhere.
initial_duration: 0.5							# have this at 0.5s as init code in _startup_autoexec.cfg runs at 0.1s after start
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_module_start func_params='"{rawparams|string}"'  {% endif %}

	_ui_clear_cache
	_ui_clear_test_cache
	
	SAVE_VARIABLE VARIABLE=module_ui_loaded VALUE=1					#flag via persistent variable that this module is loaded
	SAVE_VARIABLE VARIABLE=ui_err_flag VALUE=0						#init error flag via persistent variable that this module is not in error

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_module_start {% endif %}

#--------------------------------------------------------------------

[gcode_macro _ui_vars]
description:  ui module variables

variable_ui_input_check_recurse_period:		0.5		#seconds
variable_ui_reminder_enable:				1		#bool 1/0
variable_ui_reminder_recurse_period:		30		#secs

gcode:
	# there is none - for 'gcode module' variable use only

#--------------------------------------------------------------------


[delayed_gcode _ui_reminder]
# provides a repeating alarm to alert on a requirement for user input
initial_duration: 0
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_reminder func_params='"{rawparams|string}"'  {% endif %}

	#do things here like flash leds, make noise, etc. for user attention purposes
	M300 P100 S3000

	UPDATE_DELAYED_GCODE ID=_ui_reminder DURATION={printer["gcode_macro _ui_vars"].ui_reminder_recurse_period|int}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_reminder {% endif %}

#--------------------------------------------------------------------

[gcode_macro _start_ui_reminder]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_start_ui_reminder func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_ui_reminder DURATION={printer["gcode_macro _ui_vars"].ui_reminder_recurse_period|int}	# start a recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_start_ui_reminder {% endif %}

#--------------------------------------------------------------------

[gcode_macro _stop_ui_reminder]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_stop_ui_reminder func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_ui_reminder DURATION=0					# stop the recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_stop_ui_reminder {% endif %}

#--------------------------------------------------------------------


[delayed_gcode _ui_timeout_watchdog]
#description
initial_duration: 0
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_timeout_watchdog func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	# we've timed out, so basically kill ui input stuff and call the exception handler proc w/o parameters
	# one can sniff svv for called parameters if needed
	_stop_ui_input_loop
	_stop_ui_timeout_watchdog
	_stop_ui_reminder
	_ui_clear_cache
	
  M118 ---------- Houston... ----------

	# call the to exception handler proc - codified below to default to the _ui_exception_handler macro
	{svv.ui_exception_hdlr}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_timeout_watchdog {% endif %}

#--------------------------------------------------------------------

[gcode_macro _start_ui_timeout_watchdog]
description: Start the User Input Timeout Watchdog - param DURATION sets period
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_start_ui_timeout_watchdog func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_ui_timeout_watchdog DURATION={params.DURATION|int}					# start a recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_start_ui_timeout_watchdog {% endif %}

#--------------------------------------------------------------------

[gcode_macro _stop_ui_timeout_watchdog]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_stop_ui_timeout_watchdog func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_ui_timeout_watchdog DURATION=0					# stop the recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_stop_ui_timeout_watchdog {% endif %}

#--------------------------------------------------------------------


[delayed_gcode _await_user_input]
#description
# RCVR_MACRO = macro to run upon validated input
# can't pass dynamic parameters to delayed_gcode? so need to load RCVR_MACRO from saved variables
# had to make use of namespace workaround for in-proc flag tracking
initial_duration: 0
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_await_user_input func_params='"{rawparams|string}"'  {% endif %}

	{% set this = namespace(no_ui_input=1) %}			# work around for change visibility in same proc instance

	# this is for the case when a user enters a string that contains spaces or w/e
	{% set this2 = namespace(ui_string_flag=0) %}		# work around for change visibility in same proc instance

	{% set svv = printer.save_variables.variables %}	# set context for save_variables object

	{% set UI_Input = "Um, no UI_INPUT passed" %}

	# These here are checks to see if input received
	# TODO: consider using afi code to dynamically process the user input and simplify the code...

	# FYSA: Logically, Buttons return a STRING value, in addition to having a CLICK state flag tripped
	# this conditional set serves to limit focus to the TYPE expected - that way a stale integer/float entry
	# doesn't get associated as a STRING value and vice versa
	{% if svv.ui_input_type|upper == "STRING" %}

		{% if svv.ui_click_lt %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "LT" %}
		{% endif %}

		{% if svv.ui_click_rt %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "RT" %}
		{% endif %}

		{% if svv.ui_click_up %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "UP" %}
		{% endif %}

		{% if svv.ui_click_dn %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "DN" %}
		{% endif %}

		{% if svv.ui_click_yes %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "YES" %}
		{% endif %}

		{% if svv.ui_click_no %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "NO" %}
		{% endif %}

		{% if svv.ui_click_conf %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "CONFIRM" %}
		{% endif %}

		{% if svv.ui_click_canx %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = "CANCEL" %}
		{% endif %}

		{% if svv.ui_input_string != "" %}
			{% set this.no_ui_input = 0 %}				#clear flag
			{% set UI_Input = svv.ui_input_string %}
			{% set this2.ui_string_flag = 1 %}			#set flag to pass '"string"' vs. string (raw)
		{% endif %}

	{% elif svv.ui_input_type|upper == "INTEGER" %} 

		{% if svv.ui_input_integer != -9999999 %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = svv.ui_input_integer %}
		{% endif %}

	{% elif svv.ui_input_type|upper == "FLOAT" %} 

		{% if svv.ui_input_float != -9999999.99 %}
			{% set this.no_ui_input = 0 %}	#clear flag
			{% set UI_Input = svv.ui_input_float %}
		{% endif %}
		
	{% endif %}

	{% if this.no_ui_input == 1 %}

		# No User Input so continue to recurse until to is reached or user input is provided
		UPDATE_DELAYED_GCODE ID=_await_user_input DURATION={printer["gcode_macro _ui_vars"].ui_input_check_recurse_period}

	{% else %}

		# ok, we got some input so kill timeout & alarm
		_stop_ui_timeout_watchdog
		_stop_ui_reminder

		# M118 {"<BR><BR>UI: >" ~ UI_Input ~ "< being passed to RCVR_MACRO proc: " ~ svv.ui_rcvr_macro ~ "<BR><BR>"}

		# BOUNDS CHECK
		_validate_user_input	# this forces an 'exception' (the ui_input_timeout proc) if input is 'faulty'

		# link to a proc passed by name, passing user input as a parameter,
		# wrapping in quotes if needed, and escaping embedded quotes
		{% if this2.ui_string_flag == 0 %}
			{svv.ui_rcvr_macro} UI_INPUT={UI_Input}
		{% else %} # if a string was entered, make sure to stringify it and excape any embedded quote marks
			{svv.ui_rcvr_macro} UI_INPUT='"{UI_Input|replace("\"","\\\"")}"'
		{% endif %}

	{% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_await_user_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _start_ui_input_loop]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_start_ui_input_loop func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_await_user_input DURATION={printer["gcode_macro _ui_vars"].ui_input_check_recurse_period}	# start a recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_start_ui_input_loop {% endif %}

#--------------------------------------------------------------------

[gcode_macro _stop_ui_input_loop]
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_stop_ui_input_loop func_params='"{rawparams|string}"'  {% endif %}

	UPDATE_DELAYED_GCODE ID=_await_user_input DURATION=0					# stop the recursive pause alarm

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_stop_ui_input_loop {% endif %}

#--------------------------------------------------------------------


[gcode_macro GET_USER_INPUT]
description: main macro for waiting for user input  TYPE, if passed, will determine required TYPE
# PROMPT to display in console before user input
# RCVR_MACRO proc to run after input received - said proc will need to query svv for values
# TYPE - the TYPE of input needed - string, integer, float
# TO_PERIOD - period in seconds to wait for user input
# EXCPT_HDLR - proc to call in the event of a user input timeout

# bounds to apply checks on user input against
# for Integer/Float TYPE, user input must be >=low and <=high
# if string  TYPE, ceiling(low)/ceiling(hi) drive char count checks
# BOUNDS_HI
# BOUNDS_LO

# react based on state - if idle, if printing, if paused, if error, if ...
# may need to impute a pause if not already done and in a print.?.
gcode:
	
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=get_user_input func_params='"{rawparams|string}"'  {% endif %}
	
 M118 ___ start GET_USER_INPUT: {rawparams}

	_ui_clear_cache

	SAVE_VARIABLE VARIABLE=ui_bad_input VALUE=0	# clear a flag

	{% set ui_input_prompt = params.PROMPT|default("Awaiting User Input") %}
	SAVE_VARIABLE VARIABLE=ui_input_prompt VALUE='"{ui_input_prompt}"'

	{% set ui_rcvr_macro = params.RCVR_MACRO|default("_test_show_user_input") %}
	SAVE_VARIABLE VARIABLE=ui_rcvr_macro VALUE='"{ui_rcvr_macro}"'

	{% set ui_input_type = params.TYPE|default("STRING") %}
	# allow for abbreviations - int/integer, str/string, flt/float
	{% if ui_input_type|upper == "STR" %}
		{% set ui_input_type = "STRING" %}
	{% elif ui_input_type|upper == "INT" %}
		{% set ui_input_type = "INTEGER" %}
	{% elif ui_input_type|upper == "FLT" %}
		{% set ui_input_type = "FLOAT" %}
	{% endif %}
	SAVE_VARIABLE VARIABLE=ui_input_type VALUE='"{ui_input_type|upper}"'

	{% set ui_input_to_period = params.TO_PERIOD|default(120)|int %}
	SAVE_VARIABLE VARIABLE=ui_input_to_period VALUE={ui_input_to_period}

	{% set ui_exception_hdlr = params.EXCPT_HDLR|default("_ui_exception_handler") %}
	SAVE_VARIABLE VARIABLE=ui_exception_hdlr VALUE='"{ui_exception_hdlr}"'

	{% if ui_input_type|upper == "STRING" %}
		{% set ui_dflt_bnd_lo = 1 %}
		{% set ui_dflt_bnd_hi = 255 %}
	{% else %}
		{% set ui_dflt_bnd_lo = -999999999 %}
		{% set ui_dflt_bnd_hi = 999999999 %}
	{% endif %}

	{% set ui_input_bounds_lo = params.BOUNDS_LO|default(ui_dflt_bnd_lo) %}
	SAVE_VARIABLE VARIABLE=ui_input_bounds_lo VALUE={ui_input_bounds_lo}
	
	{% set ui_input_bounds_hi = params.BOUNDS_HI|default(ui_dflt_bnd_hi) %}
	SAVE_VARIABLE VARIABLE=ui_input_bounds_hi VALUE={ui_input_bounds_hi}

	{% set ui_input_rawparams = rawparams|replace("\"","\\\"") %}
	SAVE_VARIABLE VARIABLE=ui_input_rawparams VALUE='"{ui_input_rawparams}"'
	
	SAVE_VARIABLE VARIABLE=ui_rcvr_macro	VALUE='"{ui_rcvr_macro}"'

	{% if ui_input_type|upper == "STRING" %}
		{% set hint_type = "String" %}
		{% set ui_hint = ui_input_bounds_lo|float|round(0, 'floor')|int ~ " <= length <= " ~ ui_input_bounds_hi|float|round(0, 'ceil')|int %}
	{% elif ui_input_type|upper == "INTEGER" %}
		{% set hint_type = "Integer" %}
		{% set ui_hint = ui_input_bounds_lo|float|round(0, 'floor')|int ~ " <= value <= " ~ ui_input_bounds_hi|float|round(0, 'ceil')|int %}
	{% else %} # float
		{% set hint_type = "Float" %}
		{% set ui_hint = ui_input_bounds_lo|float                       ~ " <= value <= " ~                      ui_input_bounds_hi|float %}
	{% endif %}

	M118 { ">------------------------------<BR>" ~ hint_type ~ " input needed (w/in " ~ ui_input_to_period ~ "s): " ~ ui_hint ~ "<BR>" ~ ui_input_prompt ~ "<BR><BR>" }

	# likely need to pause and then set timeouts for HE and Bed, or if flagged to timeout,
	
	{% if printer.idle_timeout.state == "Printing" %}
	# force a pause
	{% endif %}
	
	{% if printer.idle_timeout.state == "Printing" %}	#temps above 
	# set timeouts for HE and Bed
	{% endif %}

	_start_ui_timeout_watchdog DURATION={ui_input_to_period}	# set input timeout watchdog
	_start_ui_input_loop										# start input loop immediately

	{% if printer["gcode_macro _ui_vars"].ui_reminder_enable %}
		_start_ui_reminder
	{% endif %}

	# do we need to block or non_blocking_stall here???
	# or not block but rather carry on???

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=get_user_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _ui_exception_handler]			# default exception handler
description: default macro called in the event of a user input timeout or out of bounds/bad user entry
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_ui_exception_handler func_params='"{rawparams|string}"'  {% endif %}

 M118 ++++++++++ HOUSTON HERE ++++++++++
 
	_annunciate_bad_input

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	{% if svv.ui_bad_input != 0 %}
		{% set exception_hint = "Bad Input Received" %}
	{% else %}
		{% set exception_hint = svv.ui_input_to_period ~ "s timeout" %}
	{% endif %}
	
	{% set exception_hint = exception_hint ~ " - expecting a " ~ svv.ui_input_type ~ " entry " %}

	{% if svv.ui_input_type|upper == "STRING" %}
		{% set exception_hint = exception_hint ~ "of between " ~ svv.ui_input_bounds_lo|round(0, 'floor')|int ~ " and " ~ svv.ui_input_bounds_hi|round(0, 'ceil')|int ~ " char length." %}
	{% elif svv.ui_input_type|upper == "INTEGER" %}
		{% set exception_hint = exception_hint ~ "between values of " ~ svv.ui_input_bounds_lo|round(0, 'floor')|int ~ " and " ~ svv.ui_input_bounds_hi|round(0, 'ceil')|int ~ " (inclusive)." %}
	{% else %} # float
		{% set exception_hint = exception_hint ~ "between values of " ~ svv.ui_input_bounds_lo|float ~ " and " ~ svv.ui_input_bounds_hi|float ~ " (inclusive)." %}
	{% endif %}

	{% set exception_hint = exception_hint ~ "  Please Try Again..." %}
	
	M118 { "" ~ exception_hint ~ "<BR><BR>" }

	get_user_input {svv.ui_input_rawparams}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_ui_exception_handler {% endif %}

#--------------------------------------------------------------------

[gcode_macro _validate_user_input]
description: does simple bounds checking based on passed TYPE requirements
# the following user input bounds parameters are stored in svv
# ui_input_type - def to string (used to for string inputs as well as buttons)
# ui_input_bounds_lo - for int/flt, lowest value to get, for str, lowest # of characters - def to 1
# ui_input_bounds_hi - for int/flt, highest value to get, for str, highest # of characters - def to 255
# ui_exception_hdlr - bad input is reacted to in the same manner as a timeout, with a flag set: svv.ui_bad_input
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_validate_user_input func_params='"{rawparams|string}"'  {% endif %}

	{% set svv = printer.save_variables.variables %}				# set context for save_variables object

	{% if svv.ui_input_type|upper == "STRING"
		and svv.ui_input_string != ""
		and svv.ui_input_string|string|length >= svv.ui_input_bounds_lo|round(0, 'floor')
		and svv.ui_input_string|string|length <= svv.ui_input_bounds_hi|round(0, 'ceil') %}

		_annunciate_good_input

	{% elif svv.ui_input_type|upper == "INTEGER"
		and svv.ui_input_integer >= svv.ui_input_bounds_lo|round(0, 'floor')|int
		and svv.ui_input_integer <= svv.ui_input_bounds_hi|round(0, 'ceil')|int %}

		_annunciate_good_input

	{% elif svv.ui_input_type|upper == "FLOAT"
		and svv.ui_input_float >= svv.ui_input_bounds_lo|float
		and svv.ui_input_float <= svv.ui_input_bounds_hi|float %}

		_annunciate_good_input

	{% else %}

		# if we get here, the input did not pass simple bounds checks - so initiate an 'exception'
		
		# first stop stuffs so toes don't get stepped on
		_stop_ui_input_loop
		_stop_ui_timeout_watchdog
		_stop_ui_reminder
		_ui_clear_cache
		
  M118 ========== HOUSTON!!! ==========

		SAVE_VARIABLE VARIABLE=ui_bad_input VALUE=1					# set the flag

		# call the to exception handler proc - codified below to default to the _ui_exception_handler macro
		{svv.ui_exception_hdlr}

	{% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_validate_user_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _annunciate_good_input]
gcode:

	M3002 S2000
	M3002 S3000
	M300.1

#--------------------------------------------------------------------

[gcode_macro _annunciate_bad_input]
gcode:

	M300 P750 S350

#--------------------------------------------------------------------

[gcode_macro _test_show_user_input]			# default receiver macro - just echos user input...
description: test macro to display passed user input, if any
#UI_INPUT
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=_test_show_user_input func_params='"{rawparams|string}"'  {% endif %}

	{% set ui_input = params.UI_INPUT|default("Um, NO UI_INPUT passed.!. Why? How?") %}
	M118 {"Received Input: " ~ ui_input ~ "<BR><BR>"}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=_test_show_user_input {% endif %}

#--------------------------------------------------------------------

[gcode_macro _ui_clear_cache]
description: helper proc to wipe/initialize svv contents related to user input
gcode:
	SAVE_VARIABLE VARIABLE=ui_click_up VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_dn VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_lt VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_rt VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_yes VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_no VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_conf VALUE=0
	SAVE_VARIABLE VARIABLE=ui_click_canx VALUE=0
	
	SAVE_VARIABLE VARIABLE=ui_input_raw VALUE='""'
	
	SAVE_VARIABLE VARIABLE=ui_input_string VALUE='""'
	SAVE_VARIABLE VARIABLE=ui_input_integer VALUE=-9999999
	SAVE_VARIABLE VARIABLE=ui_input_float VALUE=-9999999.99

#--------------------------------------------------------------------

[gcode_macro UP]							# for UI button
description: up button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=yes func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_up VALUE=1
	SAVE_VARIABLE VARIABLE=ui_input_string VALUE='"UP"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=yes {% endif %}

#--------------------------------------------------------------------

[gcode_macro DN]							# for UI button
description: dn button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=yes func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_dn VALUE=1
	SAVE_VARIABLE VARIABLE=ui_input_string VALUE='"DN"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=yes {% endif %}

#--------------------------------------------------------------------

[gcode_macro LT]							# for UI button
description: LT button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=yes func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_lt VALUE=1
	SAVE_VARIABLE VARIABLE=ui_input_string VALUE='"LT"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=yes {% endif %}

#--------------------------------------------------------------------

[gcode_macro RT]							# for UI button
description: rt button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=yes func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_rt VALUE=1
	SAVE_VARIABLE VARIABLE=ui_input_string VALUE='"RT"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=yes {% endif %}

#--------------------------------------------------------------------

[gcode_macro YES]							# for UI button
description: yes button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=yes func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_yes VALUE=1
	SAVE_VARIABLE VARIABLE=ui_input_string VALUE='"YES"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=yes {% endif %}

#--------------------------------------------------------------------

[gcode_macro NO]							# for UI button
description: no button for user to stroke
gcode:
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=no func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_no VALUE=1
	SAVE_VARIABLE VARIABLE=ui_input_string VALUE='"NO"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=no {% endif %}

#--------------------------------------------------------------------

[gcode_macro CONFIRM]						# for UI button
description: confirm button for user to stroke
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=confirm func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_conf VALUE=1
	SAVE_VARIABLE VARIABLE=ui_input_string VALUE='"CONFIRM"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=confirm {% endif %}

#--------------------------------------------------------------------

[gcode_macro CANCEL]						# for UI button
description: cancel button for user to stroke
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=cancel func_params='"{rawparams|string}"'  {% endif %}
	SAVE_VARIABLE VARIABLE=ui_click_canx VALUE=1
	SAVE_VARIABLE VARIABLE=ui_input_string VALUE='"CANCEL"'
	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=cancel {% endif %}

#--------------------------------------------------------------------

[gcode_macro USER_ENTRY]					# for UI button
description: macro for user to enter integer/float numbers and QUOTED strings
gcode:

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_start function=user_entry func_params='"{rawparams|string}"'  {% endif %}

	{% set ui_input_string = params.QUOTED_STRING|default("") %}
	{% set ui_input_float = params.FLOAT|default(-9999999.99)|float %}
	{% set ui_input_integer = params.INTEGER|default(-9999999)|int %}
	
	{% set ui_input_raw = rawparams|replace("\"","\\\"") %}
	SAVE_VARIABLE VARIABLE=ui_input_raw VALUE='"{ui_input_raw}"'

	{% if ui_input_string != "" %}
		#SAVE_VARIABLE VARIABLE=ui_input_string VALUE='"{ui_input_string|replace("\"","\\\"")}"'
		#wrappered function had a specific behavior of not saving stringified numbers as strings, by design
		#thus disabling and forcing natural behavior by calling organic klipper function directly
		_SAVE_VARIABLE_STOCK VARIABLE=ui_input_string VALUE='"{ui_input_string|replace("\"","\\\"")}"'
	{% endif %}

	{% if ui_input_integer != -9999999 %}
		SAVE_VARIABLE VARIABLE=ui_input_integer VALUE={ui_input_integer}
	{% endif %}

	{% if ui_input_float != -9999999.99 %}
		SAVE_VARIABLE VARIABLE=ui_input_float VALUE={ui_input_float}
	{% endif %}

	{% if printer["gcode_macro _printer_vars"].ptr_verb_codeflow %} _proc_end function=user_entry {% endif %}

#--------------------------------------------------------------------

